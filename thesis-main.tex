\documentclass[12pt,a4paper,openright,twoside]{book}
\usepackage[utf8]{inputenc}
\usepackage{disi-thesis}
\usepackage{code-lstlistings}
\usepackage{notes}
\usepackage{shortcuts}
\usepackage{acronym}
\usepackage{copyrightbox}
\usepackage{url}

\renewcommand{\lstlistlistingname}{Elenco dei codici}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\school{\unibo}
\programme{Corso di Laurea Triennale in Ingegneria e Scienze Informatiche}
\title{Sicurezza delle API REST: analisi sperimentale di vulnerabilità comuni e strategie di difesa}
\author{Leonardo Grimaldi}
\date{\today}
\subject{Programmazione di Reti}
\supervisor{Prof. Andrea Piroddi}
%\cosupervisor{Dott. CoSupervisor 1}
%\morecosupervisor{Dott. CoSupervisor 2}
\session{IV}
\academicyear{2024-2025}

% Definition of acronyms
\acrodef{IoT}{Internet of Thing}
\acrodef{vm}[VM]{Virtual Machine}
\acrodef{DVWA}{Damn Vulnerable Web Application}
\acrodef{OWASP}{Open Web Application Security Project}
\acrodef{PWA}{Progressive Web Application}
\acrodef{XSS}{Cross-Site Scripting}
\acrodef{SQL}{Structured Query Language}
\acrodef{XXE}{XML External Entity}
\acrodef{API}{Application Programming Interface}
\acrodef{REST}{Representational State Transfer}
\acrodef{HTTP}{HyperText Transfer Protocol}
\acrodef{ZAP}{Zed Attack Proxy}
\acrodef{URL}{Uniform Resource Locator}
\acrodef{CI/CD}{Continuous Integration/Continuous Deployment}
\mainlinespacing{1.241} % line spacing in mainmatter, comment to default (1)

\begin{document}

\frontmatter\frontispiece

\begin{abstract}	
Max 2000 characters, strict.
\end{abstract}

\begin{dedication} % this is optional
Optional. Max a few lines.
\end{dedication}

%----------------------------------------------------------------------------------------
\tableofcontents   
\listoffigures     % (optional) comment if empty
\lstlistoflistings % (optional) comment if empty
%----------------------------------------------------------------------------------------

\mainmatter

%----------------------------------------------------------------------------------------
\chapter{Introduzione}
\label{chap:introduction}
%----------------------------------------------------------------------------------------
Le vulnerabilità web sono una delle principali minacce alla sicurezza delle applicazioni odierne.
Di recente, una falla di sicurezza su un portale web automobilistico ha portato all'accesso completo su un sistema aziendale statunitense, consentendo anche l'accesso fisico ad automobili e segreti aziendali\cite{eaton-defcon}. 
\par
In questa tesi sono state esplorate alcune delle vulnerabilità più comuni nelle API REST con l'ausilio di un'applicazione web vulnerabile chiamata OWASP Juice Shop. Inoltre è stato mostrato codice di esempio per ogni vulnerabilità elencata e sono state proposte delle contromisure per mitigare i rischi associati. L'obiettivo di questa tesi è di fornire una panoramica sulle insidie di sicurezza più comuni nello sviluppo web e quali minacce informatiche possano derivarne. Altresì la risoluzione di queste è stata una parte integrante.
\par
La metodologia adottata per l'implementazione di contromisure si è basata su una prima analisi dell'applicazione per trovare i punti di attacco. Dopodiché si è esaminato il codice associato alla pagina vulnerabile e consultate le documentazioni in rete per trovare i migliori standard e modi di aggiornamento (\textit{patching}) del codice. Infine, dopo aver applicato le modifiche, sono stati eseguiti dei test per verificare la risoluzione della vulnerabilità e l'efficacia della contromisura adottata. 
\paragraph{Struttura della tesi}
Il primo capitolo di \nameref{chap:introduction} presenta il contesto generale e le motivazioni per i successivi capitoli. Il secondo capitolo di \nameref{chap:background} definisce alcuni concetti chiave per la comprensione della sicurezza web tra cui le \ac{API} e la lista OWASP TOP 10 con figure e riferimenti pratici. Inoltre, illustra i programmi di testing della sicurezza utilizzati nella fase di analisi e implementazione che costituiscono una parte importante della metodologia adottata.
\par
A seguire, l'\nameref{chap:analisi-del-dominio} introduce l'applicazione vulnerabile \textit{Juice Shop} che verrà sottoposta ad attacchi informatici mirati che consentiranno di approfondire i concetti teorici imparati e di utilizzare i strumenti come \ac{ZAP} per trovare vulnerabilità. Questa parte contiene numerose immagini e passi riproducibili di attacchi informatici che forniscono la base solida per la risoluzione degli stessi nel capitolo successivo. \nameref{chap:implementazione} è il capitolo centrale della tesi che contiene la descrizione delle quattro vulnerabilità comuni, il codice vulnerabile dentro \textit{Juice Shop}, la spiegazione della falla di sicurezza, il payload di attacco e infine la contromisura adottata per risolvere il problema. Infine, il capitolo di \nameref{chap:conclusioni} riassume il lavoro svolto, i limiti e i proseguimenti futuri.
\chapter{Background}
\label{chap:background}
In questo capitolo vengono descritti i concetti fondamentali che riguardano la sicurezza web sia a livello teorico che pratico.
\par
La prima definizione importante e ricorrente è di \textbf{vulnerabilità}, ovvero una debolezza nel sistema software che può essere sfruttata per comprometterne la sicurezza\cite{RFC4949}. 
\section{API REST}
Le \textbf{\ac{API}} sono un insieme di regole e protocolli che consentono la comunicazione tra servizi o programmi. Nell'ambito web un software che utilizza le \ac{API} è sicuramente il browser che continuamente scambia informazioni con i siti web per mostrare contenuti all'utente. Per far fronte alla complessità del Web è stato introdotto lo stile architetturale \textbf{\ac{REST}} che impone nuove condizioni sulle \ac{API} per renderne più semplice l'utilizzo. Alcune di queste sono:
\begin{itemize}
    \item \textbf{Client-Server}: l'utente (client) richiede servizi al server tramite richieste \ac{HTTP}
    \item \textbf{Stateless}: le richieste sono indipendenti e contengono tutte le informazioni necessarie per essere elaborate
    \item \textbf{Uniform Interface}: si addotta un formato standard di comunicazione, indipendente dal programma
    \item \textbf{Cacheable}: le risposte del server devono essere constrassegnate come memorizzabili o non memorizzabili nella cache del client
\end{itemize}
Nell'analisi di sicurezza di un applicazione la esposizione di \ac{API} è il modo principale per l'individuazione di vulnerabilità. L'architettura client-server del primo punto rende possibile l'interazione tra un utente malintenzionato e il server con i metodi \ac{HTTP} \texttt{GET}, \texttt{POST}, \texttt{PUT}, \texttt{DELETE} che devono essere gestiti in modo appropriato per evitare che l'utente legga o modifichi dati sensibili. La \cref{fig:rest-api-diagram} mostra le interazioni tra il client (computer) e le REST API del server tramite le richieste elencate prima. Si noti la presenza del database, che non viene raggiunto direttamente dal client e il formato \textit{JSON} o \textit{XML} usato per la risposta del server.
\begin{figure}
  \centering
  \copyrightbox[b]{\includegraphics[width=.8\linewidth]{figures/Rest-API-2.png}}{Autore: Seobility - Licenza: CC BY-SA 4.0\cite{seobility-license}}
  \caption{Diagramma delle interazioni tra i tre principali attori in un'architettura REST.\cite{seobility-rest-api}}
  \label{fig:rest-api-diagram}
\end{figure}
\par
La proprietà stateless del secondo punto mostra un problema di sicurezza molto diffuso: se i servizi devono avere un permesso specifico, tutte le richieste \ac{HTTP} devono essere accompagnate da una chiave di sicurezza o token per autenticare ed autorizzarne l'uso. Poiché il server non può inferire l'identità del client da richieste precedenti, è necessario che ogni richiesta contenga le credenziali di accesso. Tuttavia, nello sviluppo delle \ac{API} è comune dimenticare di implementare questi controlli di accesso, esponendo il server a vulnerabilità di \textit{Broken Access Control}. La sezione \ref{subsec:manomissione-dei-prodotti} mostra un esempio di questo tipo di vulnerabilità tramite API e descrive alcune conseguenze legate a essa.
\section{OWASP TOP 10}
La lista OWASP TOP 10\cite{owasp-top-10} è il riferimento centrale per le vulnerabilità web più comuni ed è gestita dal team \ac{OWASP}. È stata ampiamente utilizzata per la ricerca di vulnerabilità e la loro risoluzione in questa tesi. Essa contiene dieci delle più comuni categorie di vulnerabilità web, classificate tramite dati raccolti da aziende, organizzazioni e anche sondaggi. La lista viene aggiornata ogni quattro anni e la \cref{fig:owasp-10-list-2025} mostra i cambiamenti dalla scorsa edizione 2021, dove si noti il Broken Access Control è rimasto al primo posto.
\begin{figure}
  \centering
  \copyrightbox[b]{\includegraphics[width=.8\linewidth]{figures/2025-mappings.png}}{© Copyright 2021-2025 - OWASP Top 10 Team - Licenza Creative Commons Attribution 3.0 Unported License\cite{cc-attribution-3.0-unported}}
  \caption{Cambiamenti di classifica delle vulnerabilità web più comuni tra gli anni 2021 e 2025\cite{owasp-top-10-introduction}}
  \label{fig:owasp-10-list-2025}
\end{figure}
Per questa tesi si è scelto di analizzare le categorie descritte nelle seguenti sottosezioni.
\subsection{Broken Access Control}
Il \textbf{controllo degli accessi} è un processo di verifica che consente al server di determinare i permessi di accesso alle risorse. Coinvolge i due più importanti metodi di verifica dell'identità, ovvero l'\textbf{autenticazione} e l'\textbf{autorizzazione}. Il primo consiste nel verificare l'identità dell'utente tramite credenziali di accesso mentre il secondo di assegnare i permessi all'utente associato. Per esempio, per accedere a una pagina riservata come la lista di utenti registrati, è norma chiedere l'accesso tramite un username e password. Similmente, l'accesso a un endpoint API riservato richiederebbe un token di autenticazione, come un \textit{JSON Web Token} (JWT) dentro all'header di autenticazione della richiesta HTTP\cite{mdn-authorization-header}.
\begin{figure}
  \centering
  \includegraphics[width=.8\linewidth]{figures/authorization-bearer-example.png}
  \caption{Richiesta API a \texttt{/rest/basket/6} con Authorization header a riga 6}
  \label{fig:authorization-bearer-example}
\end{figure}
\par
Quando la pagina o l'API non effettua un controllo di sicurezza adeguato e consente l'accesso a utenti non autorizzati, si parla di \textbf{Broken Access Control}. La \cref{fig:authorization-bearer-example} mostra un esempio di richiesta API con header di autorizzazione contenente un token JWT. Se il server non verifica la validità del token e consente l'accesso a utenti non autorizzati, si configura una vulnerabilità di Broken Access Control.
\par
Le vulnerabilità Broken Access Control si trovano al primo posto nella lista poiché sono le più comuni e relativamente facili da sfruttare e concedono accesso potenziale a infrastrutture amministrative che espongono dati sensibili.
\subsection{Injection}
I web server utilizzano ampiamente database per memorizzare e recuperare dati. Inoltre, elaborano dati inseriti dagli utenti per fornire pagine dinamiche oppure servizi personalizzati. 
Un attacco di tipo Injection si verifica quando un attaccante riesce a inserire comandi all'interno di caselle input (non sanificate) e farle eseguire al server.
\par
Le Injection si trovano al 5° posto della lista e si dividono in due sottocategorie principali: SQL injection e \ac{XSS}.
\subsubsection{SQL Injection}
In una vulnerabilità di tipo SQL Injection l'attaccante compone una interrogazione \ac{SQL} specifica che consente di reperire dati sensibili dal database oppure di manipolare il database in modi non previsti (aggiunta di dati, eliminazione). La sezione \ref{subsec:fuga-di-dati} mostra un esempio di questa vulnerabilità importante e come viene risolta.
\subsubsection{Cross-Site Scripting (XSS)}
Le \ac{XSS} sono vulnerabilità che coinvolgono i client, gli utenti del sito, oltre che il server stesso. Spesso sfruttano codice \textit{JavaScript} per eseguire script maliziosi sulla macchina dell'utente e ottenere dati sensibili dal sito, come la password o i dati di pagamento.
\begin{sloppypar}
I loro vettori di attacco sono \ac{URL} che contengono parametri malevoli come \texttt{https://localhost:3000/search?q=<script src="javascript:alert('codice malevolo')"></script>} che vengono inviati alla vittima (client XSS) oppure pagine del web server compromesse con codice malevolo eseguito all'apertura (server XSS). La sezione \ref{sec:xss} contiene la risoluzione e alcune dimostrazioni di questa vulnerabilità.
\par
La \cref{fig:stored-xss-diagram} mostra il diagramma di sequenza di un attacco XSS di tipo \textit{stored}, dove il codice malevolo viene memorizzato sul server e inviato a ogni utente che visita la pagina compromessa. Questo tipo di attacco può essere anche sfruttato tramite la vulnerabilità Broken Access Control, risolta in sezione \ref{subsec:manomissione-dei-prodotti}.
\end{sloppypar}
\begin{figure}
    \centering
    \copyrightbox[b]{\includegraphics[width=.8\linewidth]{figures/Cross-site_scripting_attack_sequence_diagram_-_en.png}}{Copyright © di Michel Bakni sotto licenza Creative Commons Attribution-Share Alike 4.0 International\cite{cc-share-alike-4.0-international}}
    \caption{Diagramma della sequenza di attacco XSS di tipo \textit{stored}\cite{cross-site-attack-diagram}}
    \label{fig:stored-xss-diagram}
\end{figure}
\subsection{Security Misconfiguration}
Nelle specifiche di OWASP viene definito che: ``La configurazione errata avviene quando un sistema, applicazione o servizio cloud è configurato in modo non corretto dal punto di vista della sicurezza, creando vulnerabilità''\cite{owasp-security-misconfiguration}. Questa definizione comprende la visualizzazione di errori, uso di credenziali predefinite e abilitazione di pagine o servizi non necessari e quindi anche API. Durante lo sviluppo web è comune dimenticarsi di disabilitare alcune funzionalità o endpoint API che non sono più necessari, esponendo il server a potenziali attacchi informatici. La sezione \ref{subsec:interfaccia-deprecata} mostra un esempio di questa vulnerabilità e come viene risolta.
\section{Zed Attack Proxy (ZAP)}
La \ac{ZAP} è uno strumento fondamentale per la verifica di sicurezza delle applicazioni web. Funziona come proxy tra il browser e il server web, consentendo di intercettare, modificare e analizzare le richieste e le risposte HTTP. Tra le sue funzionalità principali vi sono:
\begin{itemize}
    \item Intercettazione delle richieste e risposte HTTP
    \item Scansione automatica delle vulnerabilità
    \item Analisi delle sessioni e gestione dei cookie
    \item Fuzzing delle richieste per individuare vulnerabilità
\end{itemize}
\begin{figure}
  \centering
  \includegraphics[width=.8\linewidth]{figures/zap-main-window.png}
  \caption{Finestra principale di ZAP con la lista delle richieste intercettate e il pannello di analisi della richiesta selezionata.}
  \label{fig:zap-main-window}
\end{figure}
In questa tesi si è fatto uso principalmente della intercettazione delle richieste e risposte. Nella \cref{fig:zap-main-window} viene mostrata la schermata principale di ZAP, con la cronologia delle richieste HTTP effettuate dal browser nella finestra inferiore e al centro il pannello di analisi della richiesta selezionata, da cui è possibile modificare i parametri prima di inviarla nuovamente al server con il click destro.
La sezione \ref{subsec:interfaccia-deprecata} mostra un esempio di come ZAP sia stato utilizzato per intercettare una richiesta di caricamento file e modificarne il contenuto per testare la vulnerabilità di \textit{Security Misconfiguration}. La \cref{fig:complaint-txt-zip-response} mostra come con ZAP sia possibile modificare una richiesta HTTP per inviare un file di tipo non consentito e sfruttare una vulnerabilità API del server.
\section{Postman}
Postman è uno strumento molto diffuso, usato per testare e sviluppare API. Consente di creare, inviare e analizzare richieste HTTP in modo semplice e intuitivo. Può intendersi come un'alternativa a ZAP (soprattuto al \textit{Request Editor}) per l'invio di richieste HTTP, ma con un'interfaccia più user-friendly. Tra le sue funzionalità principali vi sono:
\begin{itemize}
    \item Creazione di richieste HTTP personalizzate
    \item Gestione delle collezioni di richieste
    \item Test automatizzati delle API
    \item Generazione di documentazione per le API
\end{itemize}
Nel corso della tesi Postman è stato utilizzato principalmente per inviare richieste \texttt{PUT} e \texttt{POST} alle API del server per testare le vulnerabilità di Broken Access Control e Security Misconfiguration come in \cref{fig:api-products-put}.
\chapter{Analisi del dominio}
\label{chap:analisi-del-dominio}
\section{Applicazione vulnerabile}
Prima ancora di incominciare la valutazione di sicurezza è necessario scegliere un sito web vulnerabile. In rete sono presenti una vasta gamma di applicazioni per la simulazione di attacchi informatici, come \ac{DVWA}\cite{dvwa-github} (basato su PHP) e OWASP Juice Shop\cite{owasp-juice-shop} (basato su Node.js). In questa tesi si è scelto di utilizzare quest'ultima per modernità di tecnologie e aggiornamenti.
\subsection{OWASP Juice Shop}
\textit{Juice Shop} è un sito web che simula un portale di vendita per prodotti di vario tipo. Presenta numerose funzionalità tra cui la registrazione, ordinazione, invio di recensioni, commenti e molto altro ancora, il che la rende un'applicazione completa. Essendo ideata per l'apprendimento e la pratica del testing di sicurezza, presenta anche numerose vulnerabilità web che fanno parte della lista \ac{OWASP} TOP 10\cite{owasp-top-10}.
\begin{figure}
    \centering
    \copyrightbox{\includegraphics[scale=0.05]{figures/JuiceShop_Logo.png}}{Copyright © by Bjoern Kimminich \& the OWASP Juice Shop contributors 2014-2026. Licensed under the MIT License\cite{juice-shop-license}}
    \caption{Logo dell'applicazione OWASP Juice Shop.}
    \label{fig:juice-shop-logo}
\end{figure}
\subsection{Architettura}
L'applicazione web si divide in due componenti: il \textit{front end} e il \textit{back end}. Il front end gestisce la parte visiva dell'applicazione e fruibile dall'utente finale. È stato sviluppato con Angular, un framework moderno che consente la modulazione di elementi web scritti con TypeScript. Il back end costituisce la parte più complessa dell'applicazione, che interagisce con i database e fornisce i servizi necessari per molte funzionalità del sito. Il web server è fornito da Node.js che si affida alla libreria Express per le REST API e Sequelize per le interrogazioni al database SQLite.
\par
La \cref{fig:juice-shop-architecture} mostra tutte le componenti di sviluppo dell'applicazione. Le frecce nere indicano le chiamate o interazioni API tra di esse. Una complessità maggiore dell'applicazione porta inevitabilmente a un rischio più elevato di attacchi informatici.
\begin{figure}
    \centering
    \copyrightbox[b]{\includegraphics[width=.8\linewidth]{figures/architecture-diagram.png}}{Copyright © by Bjoern Kimminich and licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License\cite{noncommercial-noderivatives-4.0}}
    \caption{Diagramma dell'architettura dell'applicazione OWASP Juice Shop.\cite{architecture-overview}}
    \label{fig:juice-shop-architecture}
\end{figure}
\section{Esplorazione}
Una parte essenziale della risoluzione di vulnerabilità è l'analisi delle pagina web e delle richieste effettuate senza avere accesso al codice, il cosiddetto \textit{black box testing}, per individuare i principali punti e vettori di attacco. In questa sezione verranno effettuati alcuni attacchi per identificare i punti più critici dell'applicazione che consentiranno di trovare con più facilità il codice vulnerabile durante la fase di \textit{patching} del capitolo \ref{chap:implementazione}.
\subsection{Barra di ricerca}
Nella pagina principale di Juice Shop è presente una barra di ricerca che non esegue la sanificazione dell'input, ovvero consente l'inserimento di codice HTML e JavaScript. È possibile notare questo meccanismo nella \cref{fig:dom-xss-probing} dove viene inserito nella barra di ricerca il seguente codice \texttt{<h1>Test<h1>} e analizzando la pagina modificata si trova l'elemento inserito all'interno del DOM.
\begin{figure}
  \centering
  \includegraphics[width=.8\linewidth]{figures/dom-xss-probing.png}
  \caption{Probing della barra di ricerca con tag \textit{HTML} \texttt{<h1>}. L'\textit{ispeziona elementi} mostra la presenza del tag nell'albero della pagina suggerendo una possibile vulnerabilità.}
  \label{fig:dom-xss-probing}
\end{figure}
\par
Dopo aver individuato questo punto di attacco, si tenta di eseguire un payload di tipo \ac{XSS} inserendo nella barra di ricerca il seguente codice: \texttt{<iframe src="javascript:alert(`xss`)">}. La \cref{fig:dom-xss-result} mostra il risultato dell'esecuzione del payload con l'elemento \textit{iframe} inserito nel DOM e l'alert che dimostra la piena esecuzione del codice JavaScript.
\begin{figure}
  \centering
  \includegraphics[width=.8\linewidth]{figures/dom-xss-result-small.png}
  \caption{Risultato di esecuzione del script malizioso contenuto dentro un tag \texttt{<iframe>}. L'alert dimostra che il codice JavaScript è stato eseguito con successo.}
  \label{fig:dom-xss-result}
\end{figure}
\subsection{API per la ricerca}
Il componente precedente della barra di ricerca si affida a un API che può essere intercettata utilizzando \textit{ZAP}. La \cref{fig:api-search-request} mostra che il browser fa richiesta a \texttt{/rest/products/search?q=} per ottenere la lista dei prodotti da visualizzare. Navigando sull'URL se ne può avere conferma. In questo caso si può sfruttare il parametro \texttt{q} per eseguire un payload di tipo \textit{SQL Injection} contenente un comando di interrogazione. Infatti, si può ottenere l'intero schema del database (e leggerne i dati) eseguendo un attacco di tipo \textit{UNION} descritto nella sezione di \ref{sec:contribution-sql-inj} da un punto di vista risolutivo.
\begin{figure}
  \centering
  \includegraphics[width=.8\linewidth]{figures/api-search-request.png}
  \caption{Richiesta API per la ricerca dei prodotti evidenziata in blu nella finestra inferiore. In alto la risposta del server contenente i header e il JSON dei prodotti (giallo e rosa)}
  \label{fig:api-search-request}
\end{figure}
\subsection{Modifica prodotti}
Scorrendo nel codice \textit{JavaScript} \texttt{main.js} del sito web è possibile trovare con grande facilità le API utilizzate per gestire i prodotti. Una di queste è \texttt{/api/Products} (\cref{fig:api-products-devtools}). Si presuppone che l'endpoint venga utilizzato dagli amministratori per creare o modificare i prodotti, ma presto si vedrà che è possibile farne uso senza autenticazione.
\begin{figure}
\centering
\includegraphics[width=.8\linewidth]{figures/api-products-devtools.png}
\caption{Codice \textit{JavaScript} che mostra l'uso dell'endpoint \texttt{/api/Products} visualizzato nei strumenti di sviluppo del browser.}
\label{fig:api-products-devtools}
\end{figure}
\par
Visitando l'endpoint API in questione vengono mostrati in formato JSON tutti i prodotti. Aggiungendo l'id di un prodotto: \texttt{/api/Products/9} è possibile interagire con il singolo prodotto. In HTTP si hanno diversi metodi di richiesta tra cui \texttt{GET}, \texttt{POST}, \texttt{PUT} e \texttt{DELETE}. Utilizzando \textit{Postman} si può inviare una richiesta di tipo \texttt{PUT} per modificare il prodotto con id 9 (\cref{fig:api-products-put}). Nella richiesta si specifica la nuova descrizione del prodotto e si invia la richiesta senza nessun header di autenticazione. La risposta del server è positiva (codice 200) e il prodotto viene modificato con successo.
\begin{figure}
\centering
\includegraphics[width=.8\linewidth]{figures/api-products-put.png}
\caption[Esecuzione con \textit{Postman} di una richiesta \texttt{PUT} sull'endpoint dei prodotti]{Esecuzione con \textit{Postman} di una richiesta \texttt{PUT} sull'endpoint \texttt{/api/Products/9} per modificare il prodotto con id 9 senza autenticazione. La risposta del server (in basso) indica che la modifica è avvenuta con successo.}
\label{fig:api-products-put}
\end{figure}
\subsection{Pagina reclami}
Dopo aver eseguito il login con un account personale è possibile vedere il link alla pagina \textit{Complaint} nella barra laterale (\texttt{/complain}). Visitandola si è presentati con un form (\cref{fig:complaint-form}) contenente i campi \textit{Customer} (non modificabile), \textit{Message} e \textit{Invoice}, il quale consente di allegare un file opzionale. Il vettore di attacco è esattamente quest'ultimo, su cui verranno controllate le restrizioni di upload.
\begin{figure}
\centering
\includegraphics[width=.8\linewidth]{figures/complaint-form.png}
\caption{Form di invio reclami con campo di caricamento file}
\label{fig:complaint-form}
\end{figure}
\par
Tentando di allegare un file di tipo arbitrario come \texttt{.jpg} si ottiene a schermo l'errore di \cref{fig:complaint-form-forbidden-file-type} che comunica le estensioni consentite, ovvero solo \texttt{.zip} e \texttt{.pdf}. Per intercettare la richiesta (e scovare la vulnerabilità) si procede allora inserendo come allegato un file \texttt{.zip} e si analizza la richiesta dentro ZAP. La \cref{fig:complaint-form-zap-upload-prova} mostra nella finestra bianca di ZAP la richiesta POST all'endpoint \texttt{/file-upload} che carica effettivamente il file.
\begin{figure}
  \centering
  \includegraphics[width=.8\linewidth]{figures/complaint-form-forbidden-file-type.png}
  \caption{Violazione degli allegati consentiti dopo aver inserito un immagine \texttt{.jpg} nel form di invio reclami.}
  \label{fig:complaint-form-forbidden-file-type}
\end{figure}
\begin{figure}
  \centering
  \includegraphics[width=.8\linewidth]{figures/complaint-form-zap-upload-prova.png}
  \caption{Intercettazione con \textit{ZAP} di una richiesta pulita con allegato \texttt{prova.zip} visibile nel attributo \texttt{filename=""} del corpo della richiesta.}
  \label{fig:complaint-form-zap-upload-prova}
\end{figure}
\par
Aprendo il \textit{Request Editor} di ZAP viene modificato il file allegato con uno di tipo non consentito, ad esempio \texttt{.txt} nel corpo della richiesta, come mostrato in \cref{fig:complaint-form-zap-upload-text} e cliccando su \textit{Send} la richiesta modificata viene inviata al server. 
\begin{figure}
\centering
\includegraphics[width=.8\linewidth]{figures/complaint-form-zap-upload-text.png}
\caption{Richiesta HTTP modificata in \textit{ZAP} con \textit{Manual Request Editor} per allegare un file di tipo non consentito \texttt{.txt}.}
\label{fig:complaint-form-zap-upload-text}
\end{figure}
La risposta del server è nuovamente un \texttt{HTTP 204 code} e il file viene caricato con successo nonostante la violazione delle estensioni consentite. Ciò dimostra che il controllo delle estensioni è effettuato solo lato client e non sul server, permettendo così a un attaccante di caricare file arbitrari.
\chapter{Implementazione}
\label{chap:implementazione}
In questo capitolo vengono analizzati quattro tipi di vulnerabilità presenti su Juice Shop.
%Per ognuna di esse viene mostrato il codice vulnerabile, la spiegazione della falla di sicurezza, il payload di attacco e infine la contromisura adottata per risolvere il problema.
Tutto il codice riportato in questa sezione è rilasciato sotto licenza MIT\cite{juice-shop-license}.
\section{XSS (Cross-Site Scripting)}
\label{sec:xss}
La componente front end della barra di ricerca è spesso una fonte di vulnerabilità per il computer dell'utente se non gestita in modo sicuro. Molte volte i valori di ricerca non vengono sanificati (ripuliti da codice speciale come tag HTML con codice JavaScript) e ciò può portare all'esecuzione di codice non previsto sulla macchina utente. Se il valore di ricerca viene immesso nell'URL, questo può essere usato per un attacco di hacking dove si inietta del codice malizioso all'interno di un link che la vittima apre, compromettendo i suoi dati sul sito. È proprio ciò che accadde in questa sezione, dove verrà risolta una vulnerabilità \ac{XSS} nella barra di ricerca del sito.
\subsection{Barra di ricerca}
\begin{sloppypar}
Il framework Angular assiste i sviluppatori diffidando gli input provenienti da utenti e quindi implementando una rigida sanificazione dei valori da inserire nel DOM\cite{angular-xss-docs}. Tuttavia, rende anche possibile la disattivazione\cite{angular-safe-values-docs} del meccanismo di sanificazione automatica per scopi precisi (come inserimento di \texttt{<iframe>}) con \texttt{bypassSecurityTrust...}, come visibile nel \cref{lst:filterTable} che concerne la funzione di ricerca di prodotti\footnote{Il codice di questa funzione si trova all'interno di \path{frontend/src/app/search-result/search-result.component.ts}}.
\lstinputlisting[language=JavaScript,label={lst:filterTable}, caption={Filtro dei prodotti in base alla stringa di ricerca. La riga 6 mostra un uso scorretto di \texttt{bypassSecurityTrustHtml}}]{listings/filterTable.ts}
\par
In questo caso però gli sviluppatori del sito hanno commesso un errore: la barra di ricerca non necessità di particolari funzionalità aggiuntive; essa deve solamente elaborare la stringa di ricerca e restituire i prodotti che soddisfano la stringa. Nel codice quindi viene eliminato \texttt{this.sanitizer.bypassSecurityTrustHtml(queryParam)} e sostituito con \texttt{queryParam}.
\end{sloppypar}
\begin{sloppypar}
Ora avendo apportato la modifica si tenta il payload \texttt{<iframe src="javascript:alert(`xss`)">} nella barra di ricerca. Visualmente non si ha nessun riscontro e neppure nell'ispeziona elementi si vede alcuna traccia dell'elemento \texttt{<iframe>}. La \cref{fig:search-bar-iframe-payload-after} mostra l'albero degli elementi dopo l'inserimento del payload, dove si nota che l'elemento non viene inserito nel DOM, poiché contiene un tag non consentito.
\end{sloppypar}
\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/search-bar-iframe-payload-after.png}
    \caption{Payload iframe XSS nella barra di ricerca. L'albero degli elementi mostra che l'elemento non viene inserito}
    \label{fig:search-bar-iframe-payload-after}
\end{figure}
\begin{sloppypar}
Ci si può domandare cosa avviene utilizzando un payload diverso, come \texttt{<img src=javascript:alert('XSS')>}. La risposta è che Angular immette l'elemento nel DOM con la peculiarità che viene aggiunto l'attributo \textit{unsafe} (\cref{fig:search-bar-img-payload-after}) dinanzi al codice JavaScript, rendendolo del tutto inagibile e stampando in console l'errore di \cref{fig:search-bar-img-payload-console}.
\par
La vulnerabilità si ritiene così risolta poiché il codice JavaScript non viene eseguito e l'inserimento di elementi pericolosi come \texttt{<iframe>} o \texttt{<script>} non produce più nessun risultato. Ci si affida in questo caso ad Angular che esegue automaticamente la sanificazione. Per tecnologie diverse da Angular si sarebbe dovuta potenzialmente implementare una funzione di sanificazione personalizzata.
\end{sloppypar}
\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/search-bar-img-payload-console.png}
    \caption[Errore in console con payload di tipo XSS dentro img]{Errore in console con payload di tipo \texttt{<img src=javascript:alert('XSS')>}}
    \label{fig:search-bar-img-payload-console}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/search-bar-img-payload-after.png}
    \caption{Payload \texttt{<img src=javascript:alert('XSS')>} nella barra di ricerca. L'elemento immagine viene inserito, ma il codice JavaScript viene etichettato non sicuro}
    \label{fig:search-bar-img-payload-after}
\end{figure}
\begin{sloppypar}
% (**PATCHED**)
% Un attacco più sofisticato che si può presupporre di eseguire conoscendo il framework del sito è il [Template Injection](https://www.paloaltonetworks.com/blog/cloud-security/template-injection-vulnerabilities/). Si tratta di incorporare dentro al payload espressioni speciali come \texttt{\{\{\}\}} e far eseguire al motore JavaScript codice arbitrario e/o malizioso.
\end{sloppypar}
\section{SQL Injection}
\label{sec:contribution-sql-inj}
Le interrogazioni SQL stanno alla base di ogni sito dinamico. Mentre nella sezione precedente si è vista una vulnerabilità che coinvolge il client, qui verrà mostrato come un utente malizioso potrebbe interagire con il sito web (server) per ottenere informazioni riservate del database.
\par
Il punto di partenza per il seguente attacco è nuovamente la barra di ricerca che esegue una interrogazione vulnerabile sul server, accettando ogni tipo di parametro.
\subsection{Fuga di dati tramite API}
\label{subsec:fuga-di-dati}
\texttt{routes/search.ts}
\lstinputlisting[language=JavaScript,label={lst:searchProducts}, caption={Ricerca dei prodotti con query SQL vulnerabile}]{listings/searchProducts.ts}
\begin{sloppypar}
Nella funzione \texttt{searchProducts}\footnote{Questa funzione si può trovare dentro \path{routes/search.ts}} (\cref{lst:searchProducts}) che espone l'API di ricerca dei prodotti \texttt{/rest/products/search} è presente codice SQL vulnerabile, legato a un uso non corretto della libreria Sequelize\cite{sequelize}. Sequelize è un ORM (Object-Relational Mapping) per Node.js che consente di interagire con database come MySQL e, in questo caso, SQLite.
\end{sloppypar}
\par
La funzione \texttt{query()}\cite{sequelize-query} consente di passare un parametro stringa contenente la query SQL e restituisce una Promise\cite{mdn-promise} contenente il risultato. La vulnerabilità back-end del sito si trova precisamente nell'utilizzo di questo metodo: gli sviluppatori hanno costruito la stringa SQL in modo dinamico facendo un passaggio di parametro.
\begin{lstlisting}[language=JavaScript,label={lst:criteria-query}, caption={Interrogazione SQL di ricerca dei prodotti con criterio vulnerabile}]
models.sequelize.query(`SELECT * FROM Products WHERE ((name LIKE '%${criteria}%' OR description LIKE '%${criteria}%') AND deletedAt IS NULL) ORDER BY name`)
\end{lstlisting}
\par
Nel codice sopra riportato viene mostrata la query di selezione contenente il parametro \texttt{criteria}, ovvero la chiave di ricerca del prodotto. Questo viene fornito usando la formattazione \texttt{`\$\{chiave\}`} che corrisponde al Template Literal\cite{ts-template-literal} di TypeScript. In questo modo la query SQL può essere costruita dinamicamente e in un modo facile, ma rende possibile l'Injection poiché il parametro non viene sanificato. L'utente malizioso, infatti, potrà eseguire un attacco di tipo \texttt{UNION} per ottenere l'intero schema del database!
\par
Per procedere alla risoluzione di questo problema è necessario leggere la documentazione sulle \textit{Raw Queries}\cite{sequelize-raw-queries} di Sequelize ed utilizzare correttamente le funzionalità \textit{Replacements} oppure \textit{Bind Parameter} per eseguire la sanificazione della stringa proveniente dal client ed interagire nel modo più sicuro con il database.
Usando i \textit{replacements} si crea un formato di rimpiazzamento riscrivendo il blocco \texttt{'\%\$\{criteria\}\%'} con \texttt{:chiave}, formando la query finale in questo modo:
\begin{lstlisting}[language=SQL,label={lst:criteria-query-vul}, caption={Query SQL sicura con rimpiazzamento del parametro}]
SELECT * FROM Products WHERE ((name LIKE :chiave OR description LIKE :chiave) AND deletedAt IS NULL) ORDER BY name
\end{lstlisting}
\par
Successivamente, viene richiamato il parametro nominato \texttt{:chiave} dentro l'oggetto di opzioni passato come secondo parametro a \texttt{query()}. Il risultato di questa modifica è visibile nel \cref{lst:criteria-query-fixed}:
\begin{lstlisting}[language=JavaScript,label={lst:criteria-query-fixed}, caption={Uso di \textit{replacements} per sanificare il parametro di ricerca nel metodo \texttt{query()} di Sequelize}]
models.sequelize.query(`SELECT * FROM Products WHERE ((name LIKE :chiave OR description LIKE :chiave) AND deletedAt IS NULL) ORDER BY name`, {
    replacements: { chiave: `%${criteria}%` }
})
\end{lstlisting}
\par
Anche la wildcard \texttt{\%} (che nel \texttt{LIKE} di SQL corrisponde alla ricerca di tutti i pattern con la parola chiave) si trova ora attorno alla variabile \texttt{criteria}. Proseguendo, viene eseguito il testing di Injection per assicurarsi che la vulnerabilità sia stata corretta.La \cref{fig:rest-search-injection-union-after} mostra la risposta JSON del server dopo che si è inviata la richiesta di ricerca con il payload di Injection. Il payload \lstinline{test')) UNION SELECT sql,2,3,4,5,6,7,8,9 FROM sqlite_master--} che in precedenza poteva restituire l'intero schema SQLite ora restituisce un array vuoto.
\par
La vulnerabilità è stata in questo modo risolta, poiché la funzione back end non accetta più comandi SQL, che ora vengono trattati come stringhe di ricerca e sanificati, restituendo così solo i prodotti che soddisfano la chiave di ricerca.
\begin{figure}[h]
    \centering
    \includegraphics[width=.8\linewidth]{figures/rest-search-injection-union-after.png}
    \caption{Tentativo di Injection con UNION a \texttt{rest/search?q=} da browser e visualizzazione richiesta in ZAP}
    \label{fig:rest-search-injection-union-after}
\end{figure}
\par
\section{Broken Access Control}
Durante lo sviluppo di un web server è importante definire i permessi di accesso alle risorse ai soli utenti abilitati a utilizzarle. Per un sistema complesso è comune dimenticarsi di disabilitare gli accessi ad alcune interfacce, esponendole ad attacchi dove un hacker può modificare dati sensibili o eseguire operazioni non autorizzate. In questa sezione viene mostrato un esempio di questo tipo di vulnerabilità e le conseguenze.
\subsection{Manomissione dei prodotti}
\label{subsec:manomissione-dei-prodotti}
\par
Il file \texttt{server.ts} è il punto di entrata principale invocato all'avvio dell'applicazione Node.js. Contiene la procedura \texttt{start()} che inizializza i servizi di WebSocket riguardanti le notifiche, le metriche di Prometheus e assegna la porta di ascolto del server. Inoltre, fa uso di ExpressJS per impostare gli endpoint API personalizzati. Riunisce tutte le componenti del back end per offrire indirizzi URL all'utente finale che potrà interagire e usufruire dei servizi esposti.
\begin{lstlisting}[language=JavaScript,label={lst:server-start}, caption={Assegnazione degli endpoint API e relative funzioni \textit{middleware} di sicurezza}]
/* Baskets: Unauthorized users are not allowed to access baskets */
app.use('/rest/basket', security.isAuthorized(), security.appendUserId())
/* BasketItems: API only accessible for authenticated users */
app.use('/api/BasketItems', security.isAuthorized())
app.use('/api/BasketItems/:id', security.isAuthorized())
// [...]
/* Products: Only GET is allowed in order to view products */
app.post('/api/Products', security.isAuthorized())
app.delete('/api/Products/:id', security.denyAll())
\end{lstlisting}
\par
Il codice sopraesposto mostra come l'oggetto \texttt{app} (Express) viene invocato per creare gli endpoint API e abilitare le richieste con metodi HTTP come \texttt{GET}, \texttt{POST}, \texttt{PUT}, \texttt{DELETE} a indirizzi personalizzati. Il secondo parametro delle funzioni in \texttt{app} riceve generalmente la funzione di \textit{callback}. Questa viene utilizzata per elaborare le richieste e, nel caso più specifico, confermare l'identità dell'utente per determinarne i suoi permessi. Essa viene denominata \textit{middleware function}, poiché agisce da tramite tra la richiesta e la risposta, gestendo l'autenticazione, il logging o gli errori.
\par
In questo semplice caso, gli sviluppatori si sono dimenticati di assegnare i controlli di sicurezza sulla richiesta HTTP PUT di \texttt{/api/Products/:id}, consentendo a \textbf{tutti} gli utenti di modificare i prodotti a proprio piacimento. In questo modo, oltre a interrompere un servizio e procurare danno finanziario, l'utente malizioso potrebbe iniettare un payload XSS, inserendo script arbitrari nelle descrizioni dei prodotti.
\par
Inoltre, se il \textit{middleware} conteneva un controllo dei limiti (rate-limiting, ovvero la limitazione del numero di richieste in un intervallo di tempo), con una sola riga mancante si espone il server a un attacco DoS (Denial-of-Service).
\par
Per risolvere questa vulnerabilità occorre aggiungere il seguente blocco dentro \texttt{server.ts}:
\begin{lstlisting}[language=JavaScript,label={lst:server-start-fixed}, caption={Controllo di accesso per l'endpoint \texttt{/api/Products}}]
app.route('/api/Products')
  .post(security.isAuthorized())
  .put(security.denyAll())
  .delete(security.denyAll())
app.route('/api/Products/:id')
  .post(security.isAuthorized())
  .put(security.denyAll())
  .delete(security.denyAll())
\end{lstlisting}
\par
I servizi di \texttt{PUT} e \texttt{DELETE} vengono così rifiutati, mentre per il POST è necessario un header di autenticazione; \texttt{GET} resta abilitato normalmente per tutti. L'applicazione così modificata si rende più sicura.
\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/api-products-put-after.png}
    \caption{Errore di autorizzazione dopo aver tentato una richiesta \texttt{PUT} su \texttt{/api/Products/9}}
    \label{fig:api-products-put-after}
\end{figure}
\section{Security Misconfiguration}
Un'impostazione errata dei servizi web può portare a gravi falle di sicurezza, come l'esecuzione di codice remoto. In questa sezione viene mostrato un esempio di vulnerabilità legata al caricamento di file non sicuri che deriva da una cattiva configurazione del server.
\subsection{Interfaccia deprecata}
\label{subsec:interfaccia-deprecata}
\texttt{routes/fileUpload.ts}, \texttt{server.ts}
\par
La pagina di invio reclami \texttt{/complaint} (\cref{fig:complaint-txt-zip-payload}) consente agli utenti di allegare file di tipo \texttt{.pdf}, \texttt{.zip} (da front end). Tuttavia, intercettando la richiesta è possibile modificare il file allegato con uno di tipo diverso, come \texttt{.txt.zip}, aggirando il controllo sul front end. Questo perché il server non esegue un controllo sul tipo di estensione del file caricato, consentendo così l'upload di file non sicuri.
All'interno di \texttt{server.ts} si può notare la presenza dell'interfaccia di caricamento dei file su indirizzo \texttt{/file-upload}:
\begin{lstlisting}[language=JavaScript,label={lst:file-upload-server}]
app.post('/file-upload', uploadToMemory.single('file'), ensureFileIsPassed, metrics.observeFileUploadMetricsMiddleware(), handleZipFileUpload, handleXmlUpload, handleYamlUpload)
\end{lstlisting}
\par
Su questa API vengono eseguite diverse funzioni \textit{middleware}. Innanzitutto viene chiamata \texttt{uploadToMemory.single('file')} la quale esegue il caricamento del file nel buffer di memoria volatile, tramite la libreria \texttt{multer} di Node.JS, e aggiunge un limite di dimensione.
\begin{lstlisting}[language=JavaScript,label={lst:upload-to-memory}]
const uploadToMemory = multer({ storage: multer.memoryStorage(), limits: { fileSize: 200000 } })
\end{lstlisting}
\par
La seconda funzione \texttt{ensureFileIsPassed} controlla la presenza del file, assicurando che non sia nullo.
\par
La terza (\texttt{metrics.observeFileUploadMetricsMiddleware()}) riguarda le metriche di Prometheus ed esegue il logging del tipo di file oppure il conteggio di upload erronei.
\begin{lstlisting}[language=JavaScript,label={lst:observe-file-upload-metrics}]
export function observeFileUploadMetricsMiddleware () {
  return ({ file }: Request, res: Response, next: NextFunction) => {
    onFinished(res, () => {
      if (file != null) {
        res.statusCode < 400 ? fileUploadsCountMetric.labels(file.mimetype).inc() : fileUploadErrorsMetric.labels(file.mimetype).inc()
      }
    })
    next()
  }
}
\end{lstlisting}
\par
Le successive funzioni riguardano la elaborazione di file specifici con estensione \texttt{.zip}, \texttt{.xml} e \texttt{yaml}. In tutto questo, si può notare la \textbf{mancanza} di un'importante funzione protettiva: il controllo sul tipo di estensioni (Nel codice è già presente la funzione \texttt{checkFileType}, ma questa serve semplicemente per segnare il completamento della challenge. In un caso reale si può presupporre che i developer si siano dimenticati di eseguire il controllo oppure l'hanno realizzato male, poiché non comporta un semplice controllo della stringa di estensione). Nel Frontend di Angular è presente un controllo sul tipo di estensione, nello specifico in \texttt{frontend/src/app/complaint/complaint.component.ts}, ma occorre prestare attenzione poiché è codice lato client che può essere modificato o immediatamente aggirato intercettando la richiesta API con OWASP ZAP.
\par
Si sposta l'attenzione quindi su \texttt{routes/fileUpload.ts} dove si modificherà la funzione \texttt{checkFileType}. Si potrebbe molto facilmente pensare di usare il parametro \texttt{.mimetype} di un oggetto \texttt{Multer.File}, ma questo \textbf{non} è sicuro, poiché fa riferimento al header che viene inviato nella richiesta, che può essere intercettato dall'utente.
\par
Per eseguire un check \textbf{sicuro} occorre leggere il file per trovare il \textit{magic number}, ovvero un codice specifico che identifica il contenuto del file. Su Node.JS questo viene eseguito con la funzione \texttt{fromBuffer} o \texttt{fileTypeFromBuffer} importata dal package \texttt{file-type}. Successivamente, si tratta semplicemente di controllare che il tipo ritornato sia incluso in quelli consentiti e in caso contrario ritornare un messaggio di errore.
\begin{lstlisting}[language=JavaScript,label={lst:check-file-type-fixed}, caption={Funzione di controllo del tipo di file caricato}]
import { fromBuffer } from 'file-type'
async function checkFileType ({ file }: Request, res: Response, next: NextFunction) {
  try {
    const type = (file?.buffer != null) ? await fromBuffer(file.buffer) : undefined
    const allowedTypes = ['application/pdf', 'application/xml', 'application/zip', 'application/x-yaml', 'text/yaml']
    if (!type || !allowedTypes.includes(type.mime)) {
      res.status(415)
      next(new Error('Invalid file type'))
    }
  } catch (err) {
    res.status(503)
    next(new Error('Internal Server Error'))
  }
  next()
}
\end{lstlisting}
\par
Infine, si aggiorna \texttt{server.ts} per includere la funzione appena creata:
\begin{lstlisting}[language=JavaScript,label={lst:file-upload-server-fixed}, caption={Endpoint di caricamento file con controllo del tipo di estensione \texttt{checkFileType}}]
app.post('/file-upload', uploadToMemory.single('file'), ensureFileIsPassed, checkFileType, metrics.observeFileUploadMetricsMiddleware(), handleZipFileUpload, handleXmlUpload, handleYamlUpload)
\end{lstlisting}
\par
Ora, quando si tenta di caricare un file malevolo come \texttt{test.txt.zip} già subito si ottiene il riscontro HTTP 415, \texttt{Unsupported File Type} e la pagina HTML comunica l'errore correttamente. È stata tentata anche la modifica dell'attributo \texttt{filename=test.txt.zip} in \texttt{filename=test.txt} e la risposta è la \textit{stessa}: il patch della vulnerabilità è stato eseguito correttamente.
\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/complaint-txt-zip-payload.png}
    \caption{Complaint form \texttt{/complaint} con allegato un file \texttt{text.txt.zip} }
    \label{fig:complaint-txt-zip-payload}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/complaint-txt-zip-response.png}
    \caption{Risposta di invio del file \texttt{test.txt.zip} a destra, con messaggio di errore \texttt{Invalid file type} e risposta HTTP 415}
    \label{fig:complaint-txt-zip-response}
\end{figure}
\par
L'ultimo procedimento da fare per completare la contromisura è quello di disabilitare effettivamente l'interfaccia deprecata. Nel \cref{lst:check-file-type-fixed} si può osservare la presenza di \texttt{handleXmlUpload} e \texttt{handleYamlUpload} che però internamente risultano deprecate per motivi di sicurezza. Questo perché entrambi sono esposti ad attacchi \ac{XXE} che consentono di eseguire \texttt{Server-Side Request Forgery} e letture di file, tramite payload specifici dentro file XML.
\par
Per disabilitarle, si possono effettivamente eliminare le funzioni di gestione di queste due estensioni da \texttt{app.post()} formando così la istruzione finale:
\begin{lstlisting}[language=JavaScript,label={lst:file-upload-server-final}, caption={Endpoint di caricamento file dopo la rimozione delle interfacce deprecate}]
app.post('/file-upload', uploadToMemory.single('file'), ensureFileIsPassed, metrics.observeFileUploadMetricsMiddleware(), checkUploadSize, checkFileType, handleZipFileUpload)
\end{lstlisting}
Il server ora non effettua più il parsing di codice \texttt{XML} o \texttt{YAML}. In più, dentro la funzione \texttt{checkFileType} precedentemente scritta si tolgono le due estensioni non più consentite:
\begin{lstlisting}[language=JavaScript]
const allowedTypes = ['application/pdf', 'application/zip']
\end{lstlisting}
Per confermare la risoluzione della falla di sicurezza, si tenta di caricare un file \texttt{test.xml.zip} e la risposta del server è un codice \texttt{HTTP 415}, come mostrato in \cref{fig:complaint-txt-zip-response}. Finalmente, il lavoro di patching è terminato a buon fine e l'API \texttt{/file-upload} non è più vulnerabile a \textit{XXE} e \textit{Unrestricted File Upload}.

\chapter{Conclusioni}
\label{chap:conclusioni}
% Conclusion chapter should point out: (1) Briefly recall problem, starting point and methods adopted, (2) Briefly report Findings, (3) Briefly discuss benefits/limitations, (4) Discuss Future Work
In questa tesi si è mostrato il lavoro svolto per la risoluzione di vulnerabilità di sicurezza di un'applicazione vulnerabile. La base di partenza è stata la teoria dietro alle \ac{API}, proseguendo con la lista delle dieci vulnerabilità più comuni che è stata un fondamento solido per l'analisi pratica dell'applicazione. L'uso di strumenti come \ac{ZAP} ha permesso di visualizzare le componenti software in interazione e di comprendere il meccanismo delle \ac{API} studiato precedentemente, contribuendo a una crescita graduale nelle abilità di caccia proattiva di minacce informatiche. In seguito alla scoperta delle stesse, la risoluzione delle vulnerabilità si è rivelata un processo sistematico che ha coinvolto una prima analisi del codice sorgente e successivamente la lettura di documentazione in rete per trovare l'approccio implementativo più sicuro e adeguato al sistema. Con un ultima fase di testing si è potuto confermare la risoluzione dei problemi di sicurezza e concludere il processo, verificando che gli attacchi precedentemente attuabili ora non sono più eseguibili.
\par
Ovviamente, la protezione da attacchi informatici non è stata terminata (e non lo sarà mai!): il continuo sviluppo di un applicazione o la sola messa in rete di un sito web espone a nuove vulnerabilità che devono essere risolte regolarmente. Un proseguimento naturale del lavoro svolto in questa tesi potrebbe essere sicuramente l'automazione del processo di scansione delle vulnerabilità e l'integrazione di test di sicurezza automatici all'interno della pipeline di sviluppo software.
\par
Nonostante lo stato di sicurezza futuro dell'applicazione, in questa tesi sono state acquisite competenze fondamentali per l'analisi e la risoluzione di vulnerabilità comuni, che potranno e sono state applicate in contesti reali di sviluppo software e sicurezza informatica.
%----------------------------------------------------------------------------------------
% BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\backmatter

%\nocite{*} % Remove this as soon as you have the first citation

\bibliographystyle{ieeetr}
\bibliography{bibliography}

\begin{acknowledgements} % this is optional
Optional. Max 1 page.
\end{acknowledgements}

\end{document}
