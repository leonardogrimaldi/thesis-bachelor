\documentclass[12pt,a4paper,openright,twoside]{book}
\usepackage[utf8]{inputenc}
\usepackage{disi-thesis}
\usepackage{code-lstlistings}
\usepackage{notes}
\usepackage{shortcuts}
\usepackage{acronym}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\school{\unibo}
\programme{Corso di Laurea Triennale in Ingegneria e Scienze Informatiche}
\title{Sicurezza delle API REST: analisi sperimentale di vulnerabilità comuni e strategie di difesa}
\author{Leonardo Grimaldi}
\date{\today}
\subject{Supervisor's course name}
\supervisor{Prof. Andrea Piroddi}
\cosupervisor{Dott. CoSupervisor 1}
\morecosupervisor{Dott. CoSupervisor 2}
\session{IV}
\academicyear{2024-2025}

% Definition of acronyms
\acrodef{IoT}{Internet of Thing}
\acrodef{vm}[VM]{Virtual Machine}
\acrodef{DVWA}{Damn Vulnerable Web Application}
\acrodef{OWASP}{Open Web Application Security Project}

\mainlinespacing{1.241} % line spacing in mainmatter, comment to default (1)

\begin{document}

\frontmatter\frontispiece

\begin{abstract}	
Max 2000 characters, strict.
\end{abstract}

\begin{dedication} % this is optional
Optional. Max a few lines.
\end{dedication}

%----------------------------------------------------------------------------------------
\tableofcontents   
\listoffigures     % (optional) comment if empty
\lstlistoflistings % (optional) comment if empty
%----------------------------------------------------------------------------------------

\mainmatter

%----------------------------------------------------------------------------------------
\chapter{Introduction}
\label{chap:introduction}
%----------------------------------------------------------------------------------------

Write your intro here.
\sidenote{Add sidenotes in this way. They are named after the author of the thesis}

You can use acronyms that your defined previously,
such as \ac{IoT}.
%
If you use acronyms twice,
they will be written in full only once
(indeed, you can mention the \ac{IoT} now without it being fully explained).
%
In some cases, you may need a plural form of the acronym.
%
For instance,
that you are discussing \acp{vm},
you may need both \ac{vm} and \acp{vm}.

\paragraph{Structure of the Thesis}

\note{At the end, describe the structure of the paper}

\chapter{State of the art}

I suggest referencing stuff as follows: \cref{fig:random-image} or \Cref{fig:random-image}

\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/random-image.pdf}
    \caption{Some random image}
    \label{fig:random-image}
\end{figure}

\section{Some cool topic}

\chapter{Contribution}
\chapter{Applicazione vulnerabile}
Prima ancora di incominciare la valutazione di sicurezza è necessario scegliere un sito web vulnerabile. In rete sono presenti una vasta gamma di applicazioni per la simulazione di attacchi informatici, come \ac{DVWA}\cite{dvwa-github} (basato su PHP) e OWASP Juice Shop\cite{owasp-juice-shop} (basato su Node.js). In questa tesi si è scelto di utilizzare quest'ultima per modernità di tecnologie e aggiornamenti.
\section{OWASP Juice Shop}
\textit{Juice Shop} è un sito web che simula un portale di vendita per prodotti di vario tipo. Presenta numerose funzionalità tra cui la registrazione, ordinazione, invio di recensioni, commenti e molto altro ancora, il che la rende un'applicazione completa. Essendo ideata per l'apprendimento e la pratica del testing di sicurezza, presenta anche numerose vulnerabilità web che fanno parte della lista \ac{OWASP} TOP 10\cite{owasp-top-10}.
\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/JuiceShop_Logo.png}
    \caption{Logo dell'applicazione OWASP Juice Shop.}
    \label{fig:juice-shop-logo}
\end{figure}
\subsection{Architettura}
L'applicazione web si divide in due componenti: il \textit{front end} e il \textit{back end}. Il front end gestisce la parte visiva dell'applicazione e fruibile dall'utente finale. È stato sviluppato con Angular, un framework moderno che consente la modulazione di elementi web scritti con TypeScript. Il back end costituisce la parte più complessa dell'applicazione, che interagisce con i database e fornisce i servizi necessari per molte funzionalità del sito. Il web server è fornito da Node.js che si affida alla libreria Express per le REST API e Sequelize per le interrogazioni al database SQLite.
\par
La figura \ref{fig:juice-shop-architecture} mostra tutte le componenti di sviluppo dell'applicazione. Le frecce nere indicano le chiamate o interazioni API tra di esse. Una complessità maggiore dell'applicazione porta inevitabilmente a un rischio più elevato di attacchi informatici.
\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/architecture-diagram.png}
    \caption{Diagramma dell'architettura dell'applicazione OWASP Juice Shop.}
    \label{fig:juice-shop-architecture}
\end{figure}
\chapter{XSS (Cross-Site Scripting)}
\section{Barra di ricerca}
\texttt{search-result.component.ts}
\par
Codice vulnerabile
\lstinputlisting[language=JavaScript,label={lst:filterTable}]{listings/filterTable.ts}
\begin{sloppypar}
Angular assiste i sviluppatori diffidando gli input provenienti da utenti e quindi implementando una rigida sanificazione dei valori da inserire nel DOM\cite{angular-xss-docs}. Tuttavia, rende anche possibile la disattivazione\cite{angular-safe-values-docs} del meccanismo di sanificazione automatica per scopi precisi (come inserimento di \texttt{<iframe>}) con \texttt{bypassSecurityTrust...}. In questo caso però gli sviluppatori del sito hanno commesso un errore: la barra di ricerca non necessità di particolari funzionalità aggiuntive; essa deve solamente elaborare la stringa di ricerca e restituire i prodotti che soddisfano la stringa. Nel codice quindi viene eliminato \texttt{this.sanitizer.bypassSecurityTrustHtml(queryParam)} e sostituito con \texttt{queryParam}.
\end{sloppypar}
\begin{sloppypar}
Ora avendo apportato la modifica si tenta il payload \texttt{<iframe src="javascript:alert(`xss`)">} nella barra di ricerca. Visualmente non si ha nessun riscontro e neppure nell'ispeziona elementi si vede alcuna traccia dell'elemento \texttt{<iframe>}. 
\end{sloppypar}
\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/search-bar-iframe-payload-after.png}
    \caption{Payload iframe XSS nella barra di ricerca. L'albero degli elementi mostra che l'elemento non viene inserito}
    \label{fig:search-bar-iframe-payload-after}
\end{figure}
\begin{sloppypar}
Ci si può domandare cosa avviene utilizzando un payload diverso, come \texttt{<img src=javascript:alert('XSS')>}. La risposta è che *Angular* immette l'elemento nel DOM con la peculiarità che viene aggiunto l'attributo *unsafe* dinanzi al codice JavaScript, rendendolo del tutto inagibile e stampando in console il seguente errore:
\end{sloppypar}
\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/search-bar-img-payload-console.png}
    \caption{Errore in console con payload img}
    \label{fig:search-bar-img-payload-console}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/search-bar-img-payload-after.png}
    \caption{Payload \texttt{<img src=javascript:alert('XSS')>} nella barra di ricerca. L'albero degli elementi mostra che l'elemento non viene inserito}
    \label{fig:search-bar-img-payload-after}
\end{figure}
\begin{sloppypar}
(**PATCHED**)
Un attacco più sofisticato che si può presupporre di eseguire conoscendo il framework del sito è il [Template Injection](https://www.paloaltonetworks.com/blog/cloud-security/template-injection-vulnerabilities/). Si tratta di incorporare dentro al payload espressioni speciali come \texttt{\{\{\}\}} e far eseguire al motore JavaScript codice arbitrario e/o malizioso.
\end{sloppypar}
\chapter{Injection}
\section{Database Schema}
\texttt{routes/search.ts}
\lstinputlisting[language=JavaScript,label={lst:searchProducts}]{listings/searchProducts.ts}
\begin{sloppypar}
In questa funzione che espone l'API di ricerca dei prodotti \texttt{/rest/products/search} è presente codice SQL vulnerabile, legato a un uso non corretto della libreria Sequelize\cite{sequelize}. *Sequelize* è un ORM (Object-Relational Mapping) per *Node.js* che consente di interagire con database come MySQL e, in questo caso, SQLite.
\end{sloppypar}
\par
La funzione \texttt{query()}\cite{sequelize-query} consente di passare un parametro stringa contenente la query SQL e restituisce una Promise\cite{mdn-promise} contenente il risultato. La vulnerabilità back-end del sito si trova precisamente nell'utilizzo di questo metodo: gli sviluppatori hanno costruito la stringa SQL in modo dinamico facendo un pass  aggio di parametro.
\begin{lstlisting}[language=JavaScript,label={lst:criteria-query}]
models.sequelize.query(`SELECT * FROM Products WHERE ((name LIKE '%${criteria}%' OR description LIKE '%${criteria}%') AND deletedAt IS NULL) ORDER BY name`)
\end{lstlisting}
\par
Nel codice sopra riportato viene mostrata la query di selezione contenente il parametro \texttt{criteria}, ovvero la chiave di ricerca del prodotto. Questo viene fornito usando la formattazione \texttt{`\$\{chiave\}`} che corrisponde al Template Literal\cite{ts-template-literal} di TypeScript. In questo modo la query SQL può essere costruita dinamicamente e in un modo facile, ma rende possibile l'Injection poiché il parametro non viene sanificato. L'utente malizioso, infatti, potrà eseguire un attacco di tipo \texttt{UNION} per ottenere l'intero schema del database!
\par
Per procedere alla risoluzione di questo problema è necessario leggere la documentazione\cite{sequelize-raw-queries} di Sequelize ed utilizzare correttamente le funzionalità *Replacements* oppure *Bind Parameter*  per eseguire la sanificazione della stringa proveniente dal client ed interagire nel modo più sicuro con il database.
Usando i *replacements* si crea un formato di rimpiazzamento riscrivendo il blocco \texttt{'\%\$\{criteria\}\%'} con \texttt{:chiave}, formando la query finale in questo modo:
\begin{lstlisting}[language=SQL,label={lst:criteria-query-vul}]
SELECT * FROM Products WHERE ((name LIKE :chiave OR description LIKE :chiave) AND deletedAt IS NULL) ORDER BY name
\end{lstlisting}.
\par
Successivamente, viene richiamato il parametro nominato \texttt{:chiave} dentro l'oggetto di opzioni passato come secondo parametro a \texttt{query()}. Il risultato sarà di questo tipo:
\begin{lstlisting}[language=JavaScript,label={lst:criteria-query-fixed}]
models.sequelize.query(`SELECT * FROM Products WHERE ((name LIKE :chiave OR description LIKE :chiave) AND deletedAt IS NULL) ORDER BY name`, {
    replacements: { chiave: `%${criteria}%` }
})
\end{lstlisting}
\par
Anche la wildcard \texttt{\%} (che nel \texttt{LIKE} di SQL corrisponde alla ricerca di tutti i pattern con la parola chiave) si trova ora attorno alla variabile \texttt{criteria}.
\par
Proseguendo, viene eseguito il testing di Injection per assicurarsi che la vulnerabilità sia stata corretta:
\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/rest-search-injection-union-after.png}
    \caption{Tentativo di Injection con UNION a \texttt{rest/search?q=} da browser e visualizzazione richiesta in ZAP}
    \label{fig:rest-search-injection-union-after}
\end{figure}
\par
Il payload \lstinline{test')) UNION SELECT sql,2,3,4,5,6,7,8,9 FROM sqlite_master--} che in precedenza restituiva l'intero schema SQLite ora restituisce un array vuoto.
\chapter{Broken Access Control}
\section{Product Tampering}
\texttt{server.ts}
\par
Il file \texttt{server.ts} è il punto di entrata principale invocato all'avvio dell'applicazione Node.js. Contiene la procedura \texttt{start()} che inizializza i servizi di WebSocket riguardanti le notifiche, le metriche di Prometheus e assegna la porta di ascolto del server. Inoltre, fa uso di **ExpressJS** per impostare gli endpoint API personalizzati. Riunisce tutte le componenti del back-end per offrire indirizzi URL all'utente finale che potrà interagire ed usufruire dei servizi esposti.
\begin{lstlisting}[language=JavaScript,label={lst:server-start}]
/* Baskets: Unauthorized users are not allowed to access baskets */
app.use('/rest/basket', security.isAuthorized(), security.appendUserId())
/* BasketItems: API only accessible for authenticated users */
app.use('/api/BasketItems', security.isAuthorized())
app.use('/api/BasketItems/:id', security.isAuthorized())
// [...]
/* Products: Only GET is allowed in order to view products */
app.post('/api/Products', security.isAuthorized())
app.delete('/api/Products/:id', security.denyAll())
\end{lstlisting}
\par
Il codice sopraesposto mostra come \texttt{app} viene invocato per creare gli endpoint API e abilitare le richieste con metodi HTTP come \texttt{GET}, \texttt{POST}, \texttt{PUT}, \texttt{DELETE} a indirizzi personalizzati. Il secondo parametro delle funzioni in \texttt{app} riceve generalmente la funzione di *callback*. Questa viene utilizzata per elaborare le richieste e, nel caso più specifico, confermare l'identità dell'utente per determinarne i suoi permessi. Essa viene denominata *middleware function*, poiché agisce da tramite tra la richiesta e la risposta, gestendo l'autenticazione, il logging o gli errori.
\par
In questo semplice caso, gli sviluppatori si sono dimenticati di assegnare i controlli di sicurezza sulla richiesta HTTP PUT di \texttt{/api/Products/:id}, consentendo a **tutti** gli utenti di modificare i prodotti a proprio piacimento. In questo modo, oltre a interrompere un servizio e procurare danno finanziario, l'utente malizioso potrebbe iniettare un payload XSS, inserendo script arbitrari nelle descrizioni dei prodotti.
\par
Inoltre, se il middleware conteneva un controllo dei limiti (rate-limiting), con una sola riga mancante si espone il server a un attacco DoS (Denial-of-Service).
\par
Per risolvere questa vulnerabilità occorre aggiungere il seguente blocco dentro \texttt{server.ts}:
\begin{lstlisting}[language=JavaScript,label={lst:server-start-fixed}]
app.route('/api/Products')
.post(security.isAuthorized())
.put(security.denyAll())
.delete(security.denyAll())
app.route('/api/Products/:id')
.post(security.isAuthorized())
.put(security.denyAll())
.delete(security.denyAll())
\end{lstlisting}
\par
I servizi di \texttt{PUT} e \texttt{DELETE} vengono così rifiutati, mentre per il POST è necessario un header di autenticazione; \texttt{GET} resta abilitato normalmente per tutti. L'applicazione così modificata si rende più sicura.
\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/api-products-put-after.png}
    \caption{Errore di autorizzazione dopo aver tentato una richiesta \texttt{PUT} su \texttt{/api/Products/9}}
    \label{fig:api-products-put-after}
\end{figure}
\chapter{Security Misconfiguration}

\section{Deprecated Interface}
\texttt{routes/fileUpload.ts}, \texttt{server.ts}
\par
All'interno di \texttt{server.ts} si può notare la presenza dell'interfaccia di caricamento dei file su indirizzo \texttt{/file-upload}:
\begin{lstlisting}[language=JavaScript,label={lst:file-upload-server}]
app.post('/file-upload', uploadToMemory.single('file'), ensureFileIsPassed, metrics.observeFileUploadMetricsMiddleware(), handleZipFileUpload, handleXmlUpload, handleYamlUpload)
\end{lstlisting}
\par
Su questa API vengono eseguite diverse funzioni *middleware*. Innanzitutto viene chiamata \texttt{uploadToMemory.single('file')} la quale esegue il caricamento del file nel buffer di memoria volatile, tramite la libreria \texttt{multer} di *Node.JS*, e aggiunge un limite di dimensione.
\begin{lstlisting}[language=JavaScript,label={lst:upload-to-memory}]
const uploadToMemory = multer({ storage: multer.memoryStorage(), limits: { fileSize: 200000 } })
\end{lstlisting}
\par
La seconda funzione \texttt{ensureFileIsPassed} controlla la presenza del file, assicurando che non sia nullo. La terza (\texttt{metrics.observeFileUploadMetricsMiddleware()}) riguarda le metriche di *Prometheus* ed esegue il logging del tipo di file oppure il conteggio di upload erronei.
\begin{lstlisting}[language=JavaScript,label={lst:observe-file-upload-metrics}]
export function observeFileUploadMetricsMiddleware () {
  return ({ file }: Request, res: Response, next: NextFunction) => {
    onFinished(res, () => {
      if (file != null) {
        res.statusCode < 400 ? fileUploadsCountMetric.labels(file.mimetype).inc() : fileUploadErrorsMetric.labels(file.mimetype).inc()
      }
    })
    next()
  }
}
\end{lstlisting}
\par
Le successive funzioni riguardano la elaborazione di file specifici con estensione \texttt{.zip}, \texttt{.xml} e \texttt{yaml}. In tutto questo, si può notare la mancanza di un'importante funzione prottetiva: il controllo sul tipo di estensioni (Nel codice è già presente la funzione \texttt{checkFileType}, ma questa serve semplicemente per segnare il completamento della challenge. In un caso reale si può presuppore che i developer si siano dimenticati di eseguire il controllo oppure l'hanno realizzato male, poiché non comporta un semplice controllo della stringa di estensione). Nel Frontend di Angular è presente un controllo sul tipo di estensione, nello specifico in \texttt{frontend/src/app/complaint/complaint.component.ts}, ma occorre prestare attenzione poiché è codice lato client che può essere modificato o immediatamente aggirato intercettando la richiesta API con OWASP ZAP.
\par
Si sposta l'attenzione quindi su \texttt{routes/fileUpload.ts} dove si modificherà la funzione \texttt{checkFileType}. Si potrebbe molto facilmente pensare di usare il parametro \texttt{.mimetype} di un oggetto \texttt{Multer.File}, ma questo **non** è sicuro, poiché fa riferimento al header che viene inviato nella richiesta, che può essere intercettato dall'utente.
\par
Per eseguire un check sicuro occorre leggere il file per trovare il *magic number*, ovvero un codice specifico che identifica il contenuto del file. Su *Node.JS* questo viene eseguito con la funzione \texttt{fromBuffer} o \texttt{fileTypeFromBuffer} importata dal package \texttt{file-type}. Successivamente, si tratta semplicemente di controllare che il tipo ritornato sia incluso in quelli consentiti e in caso contrario ritornare un messaggio di errore.
\begin{lstlisting}[language=JavaScript,label={lst:check-file-type-fixed}]
import { fromBuffer } from 'file-type'
async function checkFileType ({ file }: Request, res: Response, next: NextFunction) {
  try {
    const type = (file?.buffer != null) ? await fromBuffer(file.buffer) : undefined
    const allowedTypes = ['application/pdf', 'application/xml', 'application/zip', 'application/x-yaml', 'text/yaml']
    if (!type || !allowedTypes.includes(type.mime)) {
      res.status(415)
      next(new Error('Invalid file type'))
    }
  } catch (err) {
    res.status(503)
    next(new Error('Internal Server Error'))
  }
  next()
}
\end{lstlisting}
\par
Infine, si aggiorna \texttt{server.ts} per includere la funzione appena creata:
\begin{lstlisting}[language=JavaScript,label={lst:file-upload-server-fixed}]
app.post('/file-upload', uploadToMemory.single('file'), ensureFileIsPassed, checkFileType, metrics.observeFileUploadMetricsMiddleware(), handleZipFileUpload, handleXmlUpload, handleYamlUpload)
\end{lstlisting}
\par
Ora, quando si tenta di caricare un file malevolo come \texttt{test.txt.zip} già subito si ottiene il riscontro HTTP 415, \texttt{Unsupported File Type} e la pagina HTML comunica l'errore correttamente. È stata tentata anche la modifica dell'attributo \texttt{filename=test.txt.zip} in \texttt{filename=test.txt} e la risposta è la **stessa**: il patch della vulnerabilità è stato eseguito correttamente.
\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/complaint-txt-zip-payload.png}
    \caption{Complaint form \texttt{/complaint} con allegato un file \texttt{text.txt.zip} }
    \label{fig:complaint-txt-zip-payload}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/complaint-txt-zip-response.png}
    \caption{Risposta di invio del file \texttt{test.txt.zip} a destra, con messaggio di errore \texttt{Invalid file type} e risposta HTTP 415}
    \label{fig:complaint-txt-zip-response}
\end{figure}
\par
L'ultimo procedimento da fare per completare la contromisura è quello di disabilitare effettivamente l'interfaccia deprecata. Nella funzione iniziale di \texttt{app.post('file-upload', ...)} si è potuto osservare la presenza di \texttt{handleXmlUpload} e \texttt{handleYamlUpload} che però internamente risultano deprecate per motivi di sicurezza. Questo perché entrambi sono esposti ad attacchi \texttt{XXE} che consentono di eseguire \texttt{Server-Side Request Forgery} e letture di file.
\par
Per disabilitarle, si possono effettivamente eliminare le funzioni di handling da \texttt{app.post()} formando così la istruzione finale:
\begin{lstlisting}[language=JavaScript,label={lst:file-upload-server-final}]
app.post('/file-upload', uploadToMemory.single('file'), ensureFileIsPassed, metrics.observeFileUploadMetricsMiddleware(), checkUploadSize, checkFileType, handleZipFileUpload)
\end{lstlisting}
Il server ora non effettua più il parsing di codice \texttt{XML} o \texttt{YAML}. In più, dentro la funzione \texttt{checkFileType} precedentemente scritta si tolgono le due estensioni non più consentite:
\begin{lstlisting}[language=JavaScript]
const allowedTypes = ['application/pdf', 'application/zip']
\end{lstlisting}
Finalmente, il lavoro di patching è terminato a buon fine e l'API \texttt{/file-upload} non è più vulnerabile a \texttt{XXE} e \texttt{Unrestricted File Upload}. 


You may also put some code snippet (which is NOT float by default), eg: \cref{lst:random-code}.

\lstinputlisting[float,language=Java,label={lst:random-code}]{listings/HelloWorld.java}

\section{Fancy formulas here}

%----------------------------------------------------------------------------------------
% BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\backmatter

%\nocite{*} % Remove this as soon as you have the first citation

\bibliographystyle{alpha}
\bibliography{bibliography}

\begin{acknowledgements} % this is optional
Optional. Max 1 page.
\end{acknowledgements}

\end{document}
