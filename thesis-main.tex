\documentclass[12pt,a4paper,openright,twoside]{book}
\usepackage[utf8]{inputenc}
\usepackage{disi-thesis}
\usepackage{code-lstlistings}
\usepackage{notes}
\usepackage{shortcuts}
\usepackage{acronym}
\usepackage{copyrightbox}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\school{\unibo}
\programme{Corso di Laurea Triennale in Ingegneria e Scienze Informatiche}
\title{Sicurezza delle API REST: analisi sperimentale di vulnerabilità comuni e strategie di difesa}
\author{Leonardo Grimaldi}
\date{\today}
\subject{Programmazione di Reti}
\supervisor{Prof. Andrea Piroddi}
%\cosupervisor{Dott. CoSupervisor 1}
%\morecosupervisor{Dott. CoSupervisor 2}
\session{IV}
\academicyear{2024-2025}

% Definition of acronyms
\acrodef{IoT}{Internet of Thing}
\acrodef{vm}[VM]{Virtual Machine}
\acrodef{DVWA}{Damn Vulnerable Web Application}
\acrodef{OWASP}{Open Web Application Security Project}
\acrodef{PWA}{Progressive Web Application}
\acrodef{XSS}{Cross-Site Scripting}
\acrodef{SQL}{Structured Query Language}
\acrodef{XXE}{XML External Entity}
\acrodef{API}{Application Programming Interface}
\acrodef{REST}{Representational State Transfer}
\acrodef{HTTP}{HyperText Transfer Protocol}
\acrodef{ZAP}{Zed Attack Proxy}
\mainlinespacing{1.241} % line spacing in mainmatter, comment to default (1)

\begin{document}

\frontmatter\frontispiece

\begin{abstract}	
Max 2000 characters, strict.
\end{abstract}

\begin{dedication} % this is optional
Optional. Max a few lines.
\end{dedication}

%----------------------------------------------------------------------------------------
\tableofcontents   
\listoffigures     % (optional) comment if empty
\lstlistoflistings % (optional) comment if empty
%----------------------------------------------------------------------------------------

\mainmatter

%----------------------------------------------------------------------------------------
\chapter{Introduzione}
\label{chap:introduction}
%----------------------------------------------------------------------------------------
Le vulnerabilità web sono una delle principali minacce alla sicurezza delle applicazioni odierne.
Di recente, una falla di sicurezza su un portale web automobilistico ha portato all'accesso completo su un sistema aziendale statunitense, consentendo l'accesso ad automobili e segreti aziendali\cite{eaton-defcon}. 

In questa tesi sono state esplorate alcune delle vulnerabilità più comuni nelle API REST con l'ausilio di un'applicazione web vulnerabile chiamata OWASP Juice Shop. Inoltre è stato mostrato codice di esempio per ogni vulnerabilità elencata e sono state proposte delle contromisure per mitigare i rischi associati. L'obiettivo di questa tesi è di fornire una panoramica sulle insidie di sicurezza più comuni nello sviluppo web e quali minacce informatiche possano derivarne.
\par
La metodologia adottata per l'implementazione di contromisure si è basata su una prima analisi dell'applicazione per trovare i punti di attacco. Dopodiché si è esaminato il codice associato alla pagina vulnerabile e consultate le documentazioni in rete per trovare i miglior standard e modi di aggiornamento (patching). 

Write your intro here.
\sidenote{Add sidenotes in this way. They are named after the author of the thesis}

You can use acronyms that your defined previously,
such as \ac{IoT}.
%
If you use acronyms twice,
they will be written in full only once
(indeed, you can mention the \ac{IoT} now without it being fully explained).
%
In some cases, you may need a plural form of the acronym.
%
For instance,
that you are discussing \acp{vm},
you may need both \ac{vm} and \acp{vm}.

\paragraph{Structure of the Thesis}

\note{At the end, describe the structure of the paper}

\chapter{Background}
\section{API REST}
Le \textbf{\ac{API}} sono un insieme di regole e protocolli che consentono la comunicazione tra servizi o programmi. Nell'ambito web un software che utilizza le \ac{API} è sicuramente il browser che continuamente scambia informazioni con i siti web per mostrare contenuti all'utente. Per far fronte alla complessità del Web è stato introdotto lo stile architetturale \textbf{\ac{REST}} che impone nuove condizioni sulle \ac{API} per renderne più semplice l'utilizzo. Alcune di queste sono:
\begin{itemize}
    \item \textbf{Client-Server}: l'utente (client) richiede servizi al server tramite richieste \ac{HTTP}
    \item \textbf{Stateless}: le richieste sono indipendenti e contengono tutte le informazioni necessarie per essere elaborate
    \item \textbf{Uniform Interface}: si addotta un formato standard di comunicazione, indipendente dal programma
    \item \textbf{Cacheable}: le risposte del server devono essere constrassegnate come memorizzabili o non memorizzabili nella cache del client
\end{itemize}
Nell'analisi di sicurezza di un applicazione la esposizione di \ac{API} è il modo principale per l'individuazione di vulnerabilità. L'architettura client-server del primo punto rende possibile l'interazione tra un utente malintenzionato e il server con i metodi \ac{HTTP} \texttt{GET}, \texttt{POST}, \texttt{PUT}, \texttt{DELETE} che devono essere gestiti in modo appropriato per evitare che l'utente legga o modifichi dati sensibili. La \cref{fig:rest-api-diagram} mostra le interazioni tra il client (computer) e le REST API del server tramite le richieste elencate prima. Si noti la presenza del database, che non viene raggiunto direttamente dal client e il formato \textit{JSON} o \textit{XML} usato per la risposta del server.
\begin{figure}
  \centering
  \copyrightbox[b]{\includegraphics[width=.8\linewidth]{figures/Rest-API-2.png}}{Autore: Seobility - Licenza: CC BY-SA 4.0\cite{seobility-license}}
  \caption{Diagramma delle interazioni tra i vari attori in un'architettura REST.\cite{seobility-rest-api}}
  \label{fig:rest-api-diagram}
\end{figure}
\par
La proprietà stateless del secondo punto mostra un problema di sicurezza molto diffuso: se i servizi devono avere un permesso specifico, tutte le richieste \ac{HTTP} devono essere accompagnate da una chiave di sicurezza o token per autenticare ed autorizzarne l'uso. Poiché il server non può inferire l'identità del client da richieste precedenti, è necessario che ogni richiesta contenga le credenziali di accesso. Tuttavia, nello sviluppo delle \ac{API} è comune dimenticare di implementare questi controlli di accesso, esponendo il server a vulnerabilità di \textit{Broken Access Control}. La sezione \ref{subsec:manomissione-dei-prodotti} mostra un esempio di questo tipo di vulnerabilità tramite API e descrive alcune conseguenze legate a essa.
\section{OWASP TOP 10}
La lista OWASP TOP 10 è il riferimento principale per le vulnerabilità web più comuni ed è gestita dal team \ac{OWASP}. È stata ampiamente utilizzata per la ricerca di vulnerabilità e la loro risoluzione in questa tesi.
\section{Zed Attack Proxy (ZAP)}
La \ac{ZAP} è uno strumento fondamentale per la verifica di sicurezza delle applicazioni web. Funziona come proxy tra il browser e il server web, consentendo di intercettare, modificare e analizzare le richieste e le risposte HTTP. Tra le sue funzionalità principali vi sono:
\begin{itemize}
    \item Intercettazione delle richieste e risposte HTTP
    \item Scansione automatica delle vulnerabilità
    \item Analisi delle sessioni e gestione dei cookie
    \item Fuzzing delle richieste per individuare vulnerabilità
\end{itemize}
\begin{figure}
  \centering
  \includegraphics[width=.8\linewidth]{figures/zap-main-window.png}
  \caption{Finestra principale di ZAP con la lista delle richieste intercettate e il pannello di analisi della richiesta selezionata.}
  \label{fig:zap-main-window}
\end{figure}
In questa tesi si è fatto uso principalmente della intercettazione delle richieste e risposte. La sezione \ref{subsec:interfaccia-deprecata} mostra un esempio di come ZAP sia stato utilizzato per intercettare una richiesta di caricamento file e modificarne il contenuto per testare la vulnerabilità di \textit{Security Misconfiguration}. La \cref{fig:complaint-txt-zip-response} mostra come con ZAP sia possibile modificare una richiesta HTTP per inviare un file di tipo non consentito e sfruttare una vulnerabilità API del server.
\chapter{State of the art}

\section{Applicazione vulnerabile}
Prima ancora di incominciare la valutazione di sicurezza è necessario scegliere un sito web vulnerabile. In rete sono presenti una vasta gamma di applicazioni per la simulazione di attacchi informatici, come \ac{DVWA}\cite{dvwa-github} (basato su PHP) e OWASP Juice Shop\cite{owasp-juice-shop} (basato su Node.js). In questa tesi si è scelto di utilizzare quest'ultima per modernità di tecnologie e aggiornamenti.
\subsection{OWASP Juice Shop}
\textit{Juice Shop} è un sito web che simula un portale di vendita per prodotti di vario tipo. Presenta numerose funzionalità tra cui la registrazione, ordinazione, invio di recensioni, commenti e molto altro ancora, il che la rende un'applicazione completa. Essendo ideata per l'apprendimento e la pratica del testing di sicurezza, presenta anche numerose vulnerabilità web che fanno parte della lista \ac{OWASP} TOP 10\cite{owasp-top-10}.
\begin{figure}
    \centering
    \copyrightbox{\includegraphics[scale=0.05]{figures/JuiceShop_Logo.png}}{Copyright © by Bjoern Kimminich \& the OWASP Juice Shop contributors 2014-2026. Licensed under the MIT License\cite{juice-shop-license}}
    \caption{Logo dell'applicazione OWASP Juice Shop.}
    \label{fig:juice-shop-logo}
\end{figure}
\subsection{Architettura}
L'applicazione web si divide in due componenti: il \textit{front end} e il \textit{back end}. Il front end gestisce la parte visiva dell'applicazione e fruibile dall'utente finale. È stato sviluppato con Angular, un framework moderno che consente la modulazione di elementi web scritti con TypeScript. Il back end costituisce la parte più complessa dell'applicazione, che interagisce con i database e fornisce i servizi necessari per molte funzionalità del sito. Il web server è fornito da Node.js che si affida alla libreria Express per le REST API e Sequelize per le interrogazioni al database SQLite.
\par
La \cref{fig:juice-shop-architecture} mostra tutte le componenti di sviluppo dell'applicazione. Le frecce nere indicano le chiamate o interazioni API tra di esse. Una complessità maggiore dell'applicazione porta inevitabilmente a un rischio più elevato di attacchi informatici.
\begin{figure}
    \centering
    \copyrightbox[b]{\includegraphics[width=.8\linewidth]{figures/architecture-diagram.png}}{Copyright © by Bjoern Kimminich and licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License\cite{noncommercial-noderivatives-4.0}}
    \caption{Diagramma dell'architettura dell'applicazione OWASP Juice Shop.\cite{architecture-overview}}
    \label{fig:juice-shop-architecture}
\end{figure}
\chapter{Contribution}
In questo capitolo vengono analizzati quattro tipi di vulnerabilità presenti su Juice Shop.
%Per ognuna di esse viene mostrato il codice vulnerabile, la spiegazione della falla di sicurezza, il payload di attacco e infine la contromisura adottata per risolvere il problema.
Tutto il codice riportato in questa sezione è rilasciato sotto licenza MIT\cite{juice-shop-license}.
\section{XSS (Cross-Site Scripting)}
La componente front end della barra di ricerca è spesso una fonte di vulnerabilità per il computer dell'utente se non gestita in modo sicuro. Molte volte i valori di ricerca non vengono sanificati (ripuliti da codice speciale come tag HTML con codice JavaScript) e ciò può portare all'esecuzione di codice non previsto sulla macchina utente. Se il valore di ricerca viene immesso nell'URL, questo può essere usato per un attacco di hacking dove si inietta del codice malizioso all'interno di un link che la vittima apre, compromettendo i suoi dati sul sito. È proprio ciò che accadde in questa sezione, dove verrà risolta una vulnerabilità \ac{XSS} nella barra di ricerca del sito.
\subsection{Barra di ricerca}
\par
\texttt{search-result.component.ts}
\begin{sloppypar}
Il framework Angular assiste i sviluppatori diffidando gli input provenienti da utenti e quindi implementando una rigida sanificazione dei valori da inserire nel DOM\cite{angular-xss-docs}. Tuttavia, rende anche possibile la disattivazione\cite{angular-safe-values-docs} del meccanismo di sanificazione automatica per scopi precisi (come inserimento di \texttt{<iframe>}) con \texttt{bypassSecurityTrust...}.
\lstinputlisting[language=JavaScript,label={lst:filterTable}, caption={Filtro dei prodotti in base alla stringa di ricerca. La riga 6 mostra un uso scorretto di \texttt{bypassSecurityTrustHtml}}]{listings/filterTable.ts}
\par
In questo caso però gli sviluppatori del sito hanno commesso un errore: la barra di ricerca non necessità di particolari funzionalità aggiuntive; essa deve solamente elaborare la stringa di ricerca e restituire i prodotti che soddisfano la stringa. Nel codice quindi viene eliminato \texttt{this.sanitizer.bypassSecurityTrustHtml(queryParam)} e sostituito con \texttt{queryParam}.
\end{sloppypar}
\begin{sloppypar}
Ora avendo apportato la modifica si tenta il payload \texttt{<iframe src="javascript:alert(`xss`)">} nella barra di ricerca. Visualmente non si ha nessun riscontro e neppure nell'ispeziona elementi si vede alcuna traccia dell'elemento \texttt{<iframe>}. La \cref{fig:search-bar-iframe-payload-after} mostra l'albero degli elementi dopo l'inserimento del payload, dove si nota che l'elemento non viene inserito nel DOM, poiché contiene un tag non consentito.
\end{sloppypar}
\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/search-bar-iframe-payload-after.png}
    \caption{Payload iframe XSS nella barra di ricerca. L'albero degli elementi mostra che l'elemento non viene inserito}
    \label{fig:search-bar-iframe-payload-after}
\end{figure}
\begin{sloppypar}
Ci si può domandare cosa avviene utilizzando un payload diverso, come \texttt{<img src=javascript:alert('XSS')>}. La risposta è che Angular immette l'elemento nel DOM con la peculiarità che viene aggiunto l'attributo \textit{unsafe} dinanzi al codice JavaScript, rendendolo del tutto inagibile e stampando in console l'errore di \cref{fig:search-bar-img-payload-console}.
\end{sloppypar}
\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/search-bar-img-payload-console.png}
    \caption{Errore in console con payload di tipo \texttt{<img src=javascript:alert('XSS')>}}
    \label{fig:search-bar-img-payload-console}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/search-bar-img-payload-after.png}
    \caption{Payload \texttt{<img src=javascript:alert('XSS')>} nella barra di ricerca. L'elemento immagine viene inserito, ma il codice JavaScript viene etichettato non sicuro}
    \label{fig:search-bar-img-payload-after}
\end{figure}
\begin{sloppypar}
(**PATCHED**)
Un attacco più sofisticato che si può presupporre di eseguire conoscendo il framework del sito è il [Template Injection](https://www.paloaltonetworks.com/blog/cloud-security/template-injection-vulnerabilities/). Si tratta di incorporare dentro al payload espressioni speciali come \texttt{\{\{\}\}} e far eseguire al motore JavaScript codice arbitrario e/o malizioso.
\end{sloppypar}
\section{SQL Injection}
Le interrogazioni SQL stanno alla base di ogni sito dinamico. Mentre nella sezione precedente si è vista una vulnerabilità che coinvolge il client, qui verrà mostrato come un utente malizioso potrebbe interagire con il sito web (server) per ottenere informazioni riservate del database.
\par
Il punto di partenza per il seguente attacco è nuovamente la barra di ricerca che esegue una interrogazione vulnerabile sul server, accettando ogni tipo di parametro.
\subsection{Fuga di dati tramite API}
\texttt{routes/search.ts}
\lstinputlisting[language=JavaScript,label={lst:searchProducts}, caption={Ricerca dei prodotti con query SQL vulnerabile}]{listings/searchProducts.ts}
\begin{sloppypar}
Nella funzione \texttt{searchProducts} che espone l'API di ricerca dei prodotti \texttt{/rest/products/search} è presente codice SQL vulnerabile, legato a un uso non corretto della libreria Sequelize\cite{sequelize}. Sequelize è un ORM (Object-Relational Mapping) per Node.js che consente di interagire con database come MySQL e, in questo caso, SQLite.
\end{sloppypar}
\par
La funzione \texttt{query()}\cite{sequelize-query} consente di passare un parametro stringa contenente la query SQL e restituisce una Promise\cite{mdn-promise} contenente il risultato. La vulnerabilità back-end del sito si trova precisamente nell'utilizzo di questo metodo: gli sviluppatori hanno costruito la stringa SQL in modo dinamico facendo un passaggio di parametro.
\begin{lstlisting}[language=JavaScript,label={lst:criteria-query}, caption={Interrogazione SQL di ricerca dei prodotti con criterio vulnerabile}]
models.sequelize.query(`SELECT * FROM Products WHERE ((name LIKE '%${criteria}%' OR description LIKE '%${criteria}%') AND deletedAt IS NULL) ORDER BY name`)
\end{lstlisting}
\par
Nel codice sopra riportato viene mostrata la query di selezione contenente il parametro \texttt{criteria}, ovvero la chiave di ricerca del prodotto. Questo viene fornito usando la formattazione \texttt{`\$\{chiave\}`} che corrisponde al Template Literal\cite{ts-template-literal} di TypeScript. In questo modo la query SQL può essere costruita dinamicamente e in un modo facile, ma rende possibile l'Injection poiché il parametro non viene sanificato. L'utente malizioso, infatti, potrà eseguire un attacco di tipo \texttt{UNION} per ottenere l'intero schema del database!
\par
Per procedere alla risoluzione di questo problema è necessario leggere la documentazione sulle \textit{Raw Queries}\cite{sequelize-raw-queries} di Sequelize ed utilizzare correttamente le funzionalità \textit{Replacements} oppure \textit{Bind Parameter} per eseguire la sanificazione della stringa proveniente dal client ed interagire nel modo più sicuro con il database.
Usando i \textit{replacements} si crea un formato di rimpiazzamento riscrivendo il blocco \texttt{'\%\$\{criteria\}\%'} con \texttt{:chiave}, formando la query finale in questo modo:
\begin{lstlisting}[language=SQL,label={lst:criteria-query-vul}, caption={Query SQL sicura con rimpiazzamento del parametro}]
SELECT * FROM Products WHERE ((name LIKE :chiave OR description LIKE :chiave) AND deletedAt IS NULL) ORDER BY name
\end{lstlisting}
\par
Successivamente, viene richiamato il parametro nominato \texttt{:chiave} dentro l'oggetto di opzioni passato come secondo parametro a \texttt{query()}. Il risultato sarà di questo tipo:
\begin{lstlisting}[language=JavaScript,label={lst:criteria-query-fixed}, caption={Uso di \textit{replacements} per sanificare il parametro di ricerca nel metodo \texttt{query()} di Sequelize}]
models.sequelize.query(`SELECT * FROM Products WHERE ((name LIKE :chiave OR description LIKE :chiave) AND deletedAt IS NULL) ORDER BY name`, {
    replacements: { chiave: `%${criteria}%` }
})
\end{lstlisting}
\par
Anche la wildcard \texttt{\%} (che nel \texttt{LIKE} di SQL corrisponde alla ricerca di tutti i pattern con la parola chiave) si trova ora attorno alla variabile \texttt{criteria}. Proseguendo, viene eseguito il testing di Injection per assicurarsi che la vulnerabilità sia stata corretta:
\begin{figure}[h]
    \centering
    \includegraphics[width=.8\linewidth]{figures/rest-search-injection-union-after.png}
    \caption{Tentativo di Injection con UNION a \texttt{rest/search?q=} da browser e visualizzazione richiesta in ZAP}
    \label{fig:rest-search-injection-union-after}
\end{figure}
\par
Il payload \lstinline{test')) UNION SELECT sql,2,3,4,5,6,7,8,9 FROM sqlite_master--} che in precedenza poteva restituire l'intero schema SQLite ora restituisce un array vuoto. La \cref{fig:rest-search-injection-union-after} mostra la risposta JSON del server dopo che si è inviata la richiesta di ricerca con il payload di Injection. La vulnerabilità è stata così risolta.
\section{Broken Access Control}
Durante lo sviluppo di un web server è importante definire i permessi di accesso alle risorse ai soli utenti abilitati a utilizzarle. Per un sistema complesso è comune dimenticarsi di disabilitare gli accessi ad alcune interfacce, esponendole ad attacchi dove un hacker può modificare dati sensibili o eseguire operazioni non autorizzate. In questa sezione viene mostrato un esempio di questo tipo di vulnerabilità e le conseguenze.
\subsection{Manomissione dei prodotti}
\label{subsec:manomissione-dei-prodotti}
\texttt{server.ts}
\par
Il file \texttt{server.ts} è il punto di entrata principale invocato all'avvio dell'applicazione Node.js. Contiene la procedura \texttt{start()} che inizializza i servizi di WebSocket riguardanti le notifiche, le metriche di Prometheus e assegna la porta di ascolto del server. Inoltre, fa uso di ExpressJS per impostare gli endpoint API personalizzati. Riunisce tutte le componenti del back-end per offrire indirizzi URL all'utente finale che potrà interagire e usufruire dei servizi esposti.
\begin{lstlisting}[language=JavaScript,label={lst:server-start}, caption={Assegnazione degli endpoint API e relative funzioni \textit{middleware} di sicurezza}]
/* Baskets: Unauthorized users are not allowed to access baskets */
app.use('/rest/basket', security.isAuthorized(), security.appendUserId())
/* BasketItems: API only accessible for authenticated users */
app.use('/api/BasketItems', security.isAuthorized())
app.use('/api/BasketItems/:id', security.isAuthorized())
// [...]
/* Products: Only GET is allowed in order to view products */
app.post('/api/Products', security.isAuthorized())
app.delete('/api/Products/:id', security.denyAll())
\end{lstlisting}
\par
Il codice sopraesposto mostra come \texttt{app} viene invocato per creare gli endpoint API e abilitare le richieste con metodi HTTP come \texttt{GET}, \texttt{POST}, \texttt{PUT}, \texttt{DELETE} a indirizzi personalizzati. Il secondo parametro delle funzioni in \texttt{app} riceve generalmente la funzione di \textit{callback}. Questa viene utilizzata per elaborare le richieste e, nel caso più specifico, confermare l'identità dell'utente per determinarne i suoi permessi. Essa viene denominata \textit{middleware function}, poiché agisce da tramite tra la richiesta e la risposta, gestendo l'autenticazione, il logging o gli errori.
\par
In questo semplice caso, gli sviluppatori si sono dimenticati di assegnare i controlli di sicurezza sulla richiesta HTTP PUT di \texttt{/api/Products/:id}, consentendo a \textbf{tutti} gli utenti di modificare i prodotti a proprio piacimento. In questo modo, oltre a interrompere un servizio e procurare danno finanziario, l'utente malizioso potrebbe iniettare un payload XSS, inserendo script arbitrari nelle descrizioni dei prodotti.
\par
Inoltre, se il \textit{middleware} conteneva un controllo dei limiti (rate-limiting, ovvero la limitazione del numero di richieste in un intervallo di tempo), con una sola riga mancante si espone il server a un attacco DoS (Denial-of-Service).
\par
Per risolvere questa vulnerabilità occorre aggiungere il seguente blocco dentro \texttt{server.ts}:
\begin{lstlisting}[language=JavaScript,label={lst:server-start-fixed}, caption={Controllo di accesso per l'endpoint \texttt{/api/Products}}]
app.route('/api/Products')
  .post(security.isAuthorized())
  .put(security.denyAll())
  .delete(security.denyAll())
app.route('/api/Products/:id')
  .post(security.isAuthorized())
  .put(security.denyAll())
  .delete(security.denyAll())
\end{lstlisting}
\par
I servizi di \texttt{PUT} e \texttt{DELETE} vengono così rifiutati, mentre per il POST è necessario un header di autenticazione; \texttt{GET} resta abilitato normalmente per tutti. L'applicazione così modificata si rende più sicura.
\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/api-products-put-after.png}
    \caption{Errore di autorizzazione dopo aver tentato una richiesta \texttt{PUT} su \texttt{/api/Products/9}}
    \label{fig:api-products-put-after}
\end{figure}
\section{Security Misconfiguration}
Un'impostazione errata dei servizi web può portare a gravi falle di sicurezza, come l'esecuzione di codice remoto. In questa sezione viene mostrato un esempio di vulnerabilità legata al caricamento di file non sicuri che deriva da una cattiva configurazione del server.
\subsection{Interfaccia deprecata}
\label{subsec:interfaccia-deprecata}
\texttt{routes/fileUpload.ts}, \texttt{server.ts}
\par
La pagina di invio reclami \texttt{/complaint} (\cref{fig:complaint-txt-zip-payload}) consente agli utenti di allegare file di tipo \texttt{.pdf}, \texttt{.zip} (da front end). Tuttavia, intercettando la richiesta è possibile modificare il file allegato con uno di tipo diverso, come \texttt{.txt.zip}, aggirando il controllo sul front end. Questo perché il server non esegue un controllo sul tipo di estensione del file caricato, consentendo così l'upload di file non sicuri.
All'interno di \texttt{server.ts} si può notare la presenza dell'interfaccia di caricamento dei file su indirizzo \texttt{/file-upload}:
\begin{lstlisting}[language=JavaScript,label={lst:file-upload-server}]
app.post('/file-upload', uploadToMemory.single('file'), ensureFileIsPassed, metrics.observeFileUploadMetricsMiddleware(), handleZipFileUpload, handleXmlUpload, handleYamlUpload)
\end{lstlisting}
\par
Su questa API vengono eseguite diverse funzioni \textit{middleware}. Innanzitutto viene chiamata \texttt{uploadToMemory.single('file')} la quale esegue il caricamento del file nel buffer di memoria volatile, tramite la libreria \texttt{multer} di Node.JS, e aggiunge un limite di dimensione.
\begin{lstlisting}[language=JavaScript,label={lst:upload-to-memory}]
const uploadToMemory = multer({ storage: multer.memoryStorage(), limits: { fileSize: 200000 } })
\end{lstlisting}
\par
La seconda funzione \texttt{ensureFileIsPassed} controlla la presenza del file, assicurando che non sia nullo.
\par
La terza (\texttt{metrics.observeFileUploadMetricsMiddleware()}) riguarda le metriche di Prometheus ed esegue il logging del tipo di file oppure il conteggio di upload erronei.
\begin{lstlisting}[language=JavaScript,label={lst:observe-file-upload-metrics}]
export function observeFileUploadMetricsMiddleware () {
  return ({ file }: Request, res: Response, next: NextFunction) => {
    onFinished(res, () => {
      if (file != null) {
        res.statusCode < 400 ? fileUploadsCountMetric.labels(file.mimetype).inc() : fileUploadErrorsMetric.labels(file.mimetype).inc()
      }
    })
    next()
  }
}
\end{lstlisting}
\par
Le successive funzioni riguardano la elaborazione di file specifici con estensione \texttt{.zip}, \texttt{.xml} e \texttt{yaml}. In tutto questo, si può notare la \textbf{mancanza} di un'importante funzione protettiva: il controllo sul tipo di estensioni (Nel codice è già presente la funzione \texttt{checkFileType}, ma questa serve semplicemente per segnare il completamento della challenge. In un caso reale si può presupporre che i developer si siano dimenticati di eseguire il controllo oppure l'hanno realizzato male, poiché non comporta un semplice controllo della stringa di estensione). Nel Frontend di Angular è presente un controllo sul tipo di estensione, nello specifico in \texttt{frontend/src/app/complaint/complaint.component.ts}, ma occorre prestare attenzione poiché è codice lato client che può essere modificato o immediatamente aggirato intercettando la richiesta API con OWASP ZAP.
\par
Si sposta l'attenzione quindi su \texttt{routes/fileUpload.ts} dove si modificherà la funzione \texttt{checkFileType}. Si potrebbe molto facilmente pensare di usare il parametro \texttt{.mimetype} di un oggetto \texttt{Multer.File}, ma questo \textbf{non} è sicuro, poiché fa riferimento al header che viene inviato nella richiesta, che può essere intercettato dall'utente.
\par
Per eseguire un check \textbf{sicuro} occorre leggere il file per trovare il \textit{magic number}, ovvero un codice specifico che identifica il contenuto del file. Su Node.JS questo viene eseguito con la funzione \texttt{fromBuffer} o \texttt{fileTypeFromBuffer} importata dal package \texttt{file-type}. Successivamente, si tratta semplicemente di controllare che il tipo ritornato sia incluso in quelli consentiti e in caso contrario ritornare un messaggio di errore.
\begin{lstlisting}[language=JavaScript,label={lst:check-file-type-fixed}, caption={Funzione di controllo del tipo di file caricato}]
import { fromBuffer } from 'file-type'
async function checkFileType ({ file }: Request, res: Response, next: NextFunction) {
  try {
    const type = (file?.buffer != null) ? await fromBuffer(file.buffer) : undefined
    const allowedTypes = ['application/pdf', 'application/xml', 'application/zip', 'application/x-yaml', 'text/yaml']
    if (!type || !allowedTypes.includes(type.mime)) {
      res.status(415)
      next(new Error('Invalid file type'))
    }
  } catch (err) {
    res.status(503)
    next(new Error('Internal Server Error'))
  }
  next()
}
\end{lstlisting}
\par
Infine, si aggiorna \texttt{server.ts} per includere la funzione appena creata:
\begin{lstlisting}[language=JavaScript,label={lst:file-upload-server-fixed}, caption={Endpoint di caricamento file con controllo del tipo di estensione \texttt{checkFileType}}]
app.post('/file-upload', uploadToMemory.single('file'), ensureFileIsPassed, checkFileType, metrics.observeFileUploadMetricsMiddleware(), handleZipFileUpload, handleXmlUpload, handleYamlUpload)
\end{lstlisting}
\par
Ora, quando si tenta di caricare un file malevolo come \texttt{test.txt.zip} già subito si ottiene il riscontro HTTP 415, \texttt{Unsupported File Type} e la pagina HTML comunica l'errore correttamente. È stata tentata anche la modifica dell'attributo \texttt{filename=test.txt.zip} in \texttt{filename=test.txt} e la risposta è la **stessa**: il patch della vulnerabilità è stato eseguito correttamente.
\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/complaint-txt-zip-payload.png}
    \caption{Complaint form \texttt{/complaint} con allegato un file \texttt{text.txt.zip} }
    \label{fig:complaint-txt-zip-payload}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/complaint-txt-zip-response.png}
    \caption{Risposta di invio del file \texttt{test.txt.zip} a destra, con messaggio di errore \texttt{Invalid file type} e risposta HTTP 415}
    \label{fig:complaint-txt-zip-response}
\end{figure}
\par
L'ultimo procedimento da fare per completare la contromisura è quello di disabilitare effettivamente l'interfaccia deprecata. Nel \cref{lst:check-file-type-fixed} si può osservare la presenza di \texttt{handleXmlUpload} e \texttt{handleYamlUpload} che però internamente risultano deprecate per motivi di sicurezza. Questo perché entrambi sono esposti ad attacchi \ac{XXE} che consentono di eseguire \texttt{Server-Side Request Forgery} e letture di file, tramite payload specifici dentro file XML.
\par
Per disabilitarle, si possono effettivamente eliminare le funzioni di gestione di queste due estensioni da \texttt{app.post()} formando così la istruzione finale:
\begin{lstlisting}[language=JavaScript,label={lst:file-upload-server-final}, caption={Endpoint di caricamento file dopo la rimozione delle interfacce deprecate}]
app.post('/file-upload', uploadToMemory.single('file'), ensureFileIsPassed, metrics.observeFileUploadMetricsMiddleware(), checkUploadSize, checkFileType, handleZipFileUpload)
\end{lstlisting}
Il server ora non effettua più il parsing di codice \texttt{XML} o \texttt{YAML}. In più, dentro la funzione \texttt{checkFileType} precedentemente scritta si tolgono le due estensioni non più consentite:
\begin{lstlisting}[language=JavaScript]
const allowedTypes = ['application/pdf', 'application/zip']
\end{lstlisting}
Per confermare la risoluzione della falla di sicurezza, si tenta di caricare un file \texttt{test.xml.zip} e la risposta del server è un codice \texttt{HTTP 415}, come mostrato in \cref{fig:complaint-txt-zip-response}. Finalmente, il lavoro di patching è terminato a buon fine e l'API \texttt{/file-upload} non è più vulnerabile a \textit{XXE} e \textit{Unrestricted File Upload}.

\chapter{Conclusioni}
Conclusion chapter should point out: (1) Briefly recall problem, starting point and methods adopted, (2) Briefly report Findings, (3) Briefly discuss benefits/limitations, (4) Discuss Future Work

%----------------------------------------------------------------------------------------
% BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\backmatter

%\nocite{*} % Remove this as soon as you have the first citation

\bibliographystyle{ieeetr}
\bibliography{bibliography}

\begin{acknowledgements} % this is optional
Optional. Max 1 page.
\end{acknowledgements}

\end{document}
